// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: IM.Buddy.proto

#ifndef PROTOBUF_IM_2eBuddy_2eproto__INCLUDED
#define PROTOBUF_IM_2eBuddy_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "IM.BaseDefine.pb.h"
// @@protoc_insertion_point(includes)

namespace IM {
namespace Buddy {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_IM_2eBuddy_2eproto();
void protobuf_AssignDesc_IM_2eBuddy_2eproto();
void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

class IMRecentContactSessionReq;
class IMRecentContactSessionRsp;
class IMUserStatNotify;
class IMUsersInfoReq;
class IMUsersInfoRsp;
class IMRemoveSessionReq;
class IMRemoveSessionRsp;
class IMAllUserReq;
class IMAllUserRsp;
class IMUsersStatReq;
class IMUsersStatRsp;
class IMChangeAvatarReq;
class IMChangeAvatarRsp;
class IMPCLoginStatusNotify;
class IMRemoveSessionNotify;
class IMDepartmentReq;
class IMDepartmentRsp;
class IMAvatarChangedNotify;
class IMChangeSignInfoReq;
class IMChangeSignInfoRsp;
class IMSignInfoChangedNotify;
class TravelRouteReq;
class TravelToolInfo;
class TravelRouteRsp;
class TravelInfo;
class TrafficInfo;
class PlayInfo;
class TravelDetail;
class GetTravelListReq;
class GetTravelTripListRsp;
class CreateTravelReq;
class CreateTravelRsp;

enum TravelType {
  TRAVEL_TYPE_TRAIN = 1,
  TRAVEL_TYPE_AIRPLANE = 2,
  TRAVEL_TYPE_BUS = 4
};
bool TravelType_IsValid(int value);
const TravelType TravelType_MIN = TRAVEL_TYPE_TRAIN;
const TravelType TravelType_MAX = TRAVEL_TYPE_BUS;
const int TravelType_ARRAYSIZE = TravelType_MAX + 1;

enum TrafficQualityType {
  QLT_TYPE_ECONOMIC = 1,
  QLT_TYPE_COMFORTABLE = 2,
  QLT_TYPE_LUXURY = 3
};
bool TrafficQualityType_IsValid(int value);
const TrafficQualityType TrafficQualityType_MIN = QLT_TYPE_ECONOMIC;
const TrafficQualityType TrafficQualityType_MAX = QLT_TYPE_LUXURY;
const int TrafficQualityType_ARRAYSIZE = TrafficQualityType_MAX + 1;

enum PlayQualityType {
  FEEL_TYPE_ECONOMIC = 1,
  FEEL_TYPE_GENERAL = 2,
  FEEL_TYPE_COMFORTABLE = 3
};
bool PlayQualityType_IsValid(int value);
const PlayQualityType PlayQualityType_MIN = FEEL_TYPE_ECONOMIC;
const PlayQualityType PlayQualityType_MAX = FEEL_TYPE_COMFORTABLE;
const int PlayQualityType_ARRAYSIZE = PlayQualityType_MAX + 1;

enum CityTrafficType {
  WALK = 1,
  BUS = 2,
  TAXI = 3
};
bool CityTrafficType_IsValid(int value);
const CityTrafficType CityTrafficType_MIN = WALK;
const CityTrafficType CityTrafficType_MAX = TAXI;
const int CityTrafficType_ARRAYSIZE = CityTrafficType_MAX + 1;

enum HotelPositionType {
  HOTEL_NEAR_CITY = 1,
  HOTEL_NEAR_VIEW_SPOT = 2,
  HOTEL_TRAFFIC_FIT = 3
};
bool HotelPositionType_IsValid(int value);
const HotelPositionType HotelPositionType_MIN = HOTEL_NEAR_CITY;
const HotelPositionType HotelPositionType_MAX = HOTEL_TRAFFIC_FIT;
const int HotelPositionType_ARRAYSIZE = HotelPositionType_MAX + 1;

// ===================================================================

class IMRecentContactSessionReq : public ::google::protobuf::MessageLite {
 public:
  IMRecentContactSessionReq();
  virtual ~IMRecentContactSessionReq();

  IMRecentContactSessionReq(const IMRecentContactSessionReq& from);

  inline IMRecentContactSessionReq& operator=(const IMRecentContactSessionReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMRecentContactSessionReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMRecentContactSessionReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMRecentContactSessionReq* other);

  // implements Message ----------------------------------------------

  IMRecentContactSessionReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMRecentContactSessionReq& from);
  void MergeFrom(const IMRecentContactSessionReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 latest_update_time = 2;
  inline bool has_latest_update_time() const;
  inline void clear_latest_update_time();
  static const int kLatestUpdateTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 latest_update_time() const;
  inline void set_latest_update_time(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMRecentContactSessionReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_latest_update_time();
  inline void clear_has_latest_update_time();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 latest_update_time_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMRecentContactSessionReq* default_instance_;
};
// -------------------------------------------------------------------

class IMRecentContactSessionRsp : public ::google::protobuf::MessageLite {
 public:
  IMRecentContactSessionRsp();
  virtual ~IMRecentContactSessionRsp();

  IMRecentContactSessionRsp(const IMRecentContactSessionRsp& from);

  inline IMRecentContactSessionRsp& operator=(const IMRecentContactSessionRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMRecentContactSessionRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMRecentContactSessionRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMRecentContactSessionRsp* other);

  // implements Message ----------------------------------------------

  IMRecentContactSessionRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMRecentContactSessionRsp& from);
  void MergeFrom(const IMRecentContactSessionRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // repeated .IM.BaseDefine.ContactSessionInfo contact_session_list = 2;
  inline int contact_session_list_size() const;
  inline void clear_contact_session_list();
  static const int kContactSessionListFieldNumber = 2;
  inline const ::IM::BaseDefine::ContactSessionInfo& contact_session_list(int index) const;
  inline ::IM::BaseDefine::ContactSessionInfo* mutable_contact_session_list(int index);
  inline ::IM::BaseDefine::ContactSessionInfo* add_contact_session_list();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::ContactSessionInfo >&
      contact_session_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::ContactSessionInfo >*
      mutable_contact_session_list();

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMRecentContactSessionRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::ContactSessionInfo > contact_session_list_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMRecentContactSessionRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMUserStatNotify : public ::google::protobuf::MessageLite {
 public:
  IMUserStatNotify();
  virtual ~IMUserStatNotify();

  IMUserStatNotify(const IMUserStatNotify& from);

  inline IMUserStatNotify& operator=(const IMUserStatNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMUserStatNotify& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMUserStatNotify* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMUserStatNotify* other);

  // implements Message ----------------------------------------------

  IMUserStatNotify* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMUserStatNotify& from);
  void MergeFrom(const IMUserStatNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .IM.BaseDefine.UserStat user_stat = 1;
  inline bool has_user_stat() const;
  inline void clear_user_stat();
  static const int kUserStatFieldNumber = 1;
  inline const ::IM::BaseDefine::UserStat& user_stat() const;
  inline ::IM::BaseDefine::UserStat* mutable_user_stat();
  inline ::IM::BaseDefine::UserStat* release_user_stat();
  inline void set_allocated_user_stat(::IM::BaseDefine::UserStat* user_stat);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMUserStatNotify)
 private:
  inline void set_has_user_stat();
  inline void clear_has_user_stat();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::IM::BaseDefine::UserStat* user_stat_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMUserStatNotify* default_instance_;
};
// -------------------------------------------------------------------

class IMUsersInfoReq : public ::google::protobuf::MessageLite {
 public:
  IMUsersInfoReq();
  virtual ~IMUsersInfoReq();

  IMUsersInfoReq(const IMUsersInfoReq& from);

  inline IMUsersInfoReq& operator=(const IMUsersInfoReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMUsersInfoReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMUsersInfoReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMUsersInfoReq* other);

  // implements Message ----------------------------------------------

  IMUsersInfoReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMUsersInfoReq& from);
  void MergeFrom(const IMUsersInfoReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // repeated uint32 user_id_list = 2;
  inline int user_id_list_size() const;
  inline void clear_user_id_list();
  static const int kUserIdListFieldNumber = 2;
  inline ::google::protobuf::uint32 user_id_list(int index) const;
  inline void set_user_id_list(int index, ::google::protobuf::uint32 value);
  inline void add_user_id_list(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      user_id_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_user_id_list();

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMUsersInfoReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > user_id_list_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMUsersInfoReq* default_instance_;
};
// -------------------------------------------------------------------

class IMUsersInfoRsp : public ::google::protobuf::MessageLite {
 public:
  IMUsersInfoRsp();
  virtual ~IMUsersInfoRsp();

  IMUsersInfoRsp(const IMUsersInfoRsp& from);

  inline IMUsersInfoRsp& operator=(const IMUsersInfoRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMUsersInfoRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMUsersInfoRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMUsersInfoRsp* other);

  // implements Message ----------------------------------------------

  IMUsersInfoRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMUsersInfoRsp& from);
  void MergeFrom(const IMUsersInfoRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // repeated .IM.BaseDefine.UserInfo user_info_list = 2;
  inline int user_info_list_size() const;
  inline void clear_user_info_list();
  static const int kUserInfoListFieldNumber = 2;
  inline const ::IM::BaseDefine::UserInfo& user_info_list(int index) const;
  inline ::IM::BaseDefine::UserInfo* mutable_user_info_list(int index);
  inline ::IM::BaseDefine::UserInfo* add_user_info_list();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserInfo >&
      user_info_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserInfo >*
      mutable_user_info_list();

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMUsersInfoRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserInfo > user_info_list_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMUsersInfoRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMRemoveSessionReq : public ::google::protobuf::MessageLite {
 public:
  IMRemoveSessionReq();
  virtual ~IMRemoveSessionReq();

  IMRemoveSessionReq(const IMRemoveSessionReq& from);

  inline IMRemoveSessionReq& operator=(const IMRemoveSessionReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMRemoveSessionReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMRemoveSessionReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMRemoveSessionReq* other);

  // implements Message ----------------------------------------------

  IMRemoveSessionReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMRemoveSessionReq& from);
  void MergeFrom(const IMRemoveSessionReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required .IM.BaseDefine.SessionType session_type = 2;
  inline bool has_session_type() const;
  inline void clear_session_type();
  static const int kSessionTypeFieldNumber = 2;
  inline ::IM::BaseDefine::SessionType session_type() const;
  inline void set_session_type(::IM::BaseDefine::SessionType value);

  // required uint32 session_id = 3;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 3;
  inline ::google::protobuf::uint32 session_id() const;
  inline void set_session_id(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMRemoveSessionReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_session_type();
  inline void clear_has_session_type();
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  int session_type_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 session_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMRemoveSessionReq* default_instance_;
};
// -------------------------------------------------------------------

class IMRemoveSessionRsp : public ::google::protobuf::MessageLite {
 public:
  IMRemoveSessionRsp();
  virtual ~IMRemoveSessionRsp();

  IMRemoveSessionRsp(const IMRemoveSessionRsp& from);

  inline IMRemoveSessionRsp& operator=(const IMRemoveSessionRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMRemoveSessionRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMRemoveSessionRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMRemoveSessionRsp* other);

  // implements Message ----------------------------------------------

  IMRemoveSessionRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMRemoveSessionRsp& from);
  void MergeFrom(const IMRemoveSessionRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 result_code = 2;
  inline bool has_result_code() const;
  inline void clear_result_code();
  static const int kResultCodeFieldNumber = 2;
  inline ::google::protobuf::uint32 result_code() const;
  inline void set_result_code(::google::protobuf::uint32 value);

  // required .IM.BaseDefine.SessionType session_type = 3;
  inline bool has_session_type() const;
  inline void clear_session_type();
  static const int kSessionTypeFieldNumber = 3;
  inline ::IM::BaseDefine::SessionType session_type() const;
  inline void set_session_type(::IM::BaseDefine::SessionType value);

  // required uint32 session_id = 4;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 4;
  inline ::google::protobuf::uint32 session_id() const;
  inline void set_session_id(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMRemoveSessionRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_result_code();
  inline void clear_has_result_code();
  inline void set_has_session_type();
  inline void clear_has_session_type();
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 result_code_;
  int session_type_;
  ::google::protobuf::uint32 session_id_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMRemoveSessionRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMAllUserReq : public ::google::protobuf::MessageLite {
 public:
  IMAllUserReq();
  virtual ~IMAllUserReq();

  IMAllUserReq(const IMAllUserReq& from);

  inline IMAllUserReq& operator=(const IMAllUserReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMAllUserReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMAllUserReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMAllUserReq* other);

  // implements Message ----------------------------------------------

  IMAllUserReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMAllUserReq& from);
  void MergeFrom(const IMAllUserReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 latest_update_time = 2;
  inline bool has_latest_update_time() const;
  inline void clear_latest_update_time();
  static const int kLatestUpdateTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 latest_update_time() const;
  inline void set_latest_update_time(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMAllUserReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_latest_update_time();
  inline void clear_has_latest_update_time();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 latest_update_time_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMAllUserReq* default_instance_;
};
// -------------------------------------------------------------------

class IMAllUserRsp : public ::google::protobuf::MessageLite {
 public:
  IMAllUserRsp();
  virtual ~IMAllUserRsp();

  IMAllUserRsp(const IMAllUserRsp& from);

  inline IMAllUserRsp& operator=(const IMAllUserRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMAllUserRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMAllUserRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMAllUserRsp* other);

  // implements Message ----------------------------------------------

  IMAllUserRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMAllUserRsp& from);
  void MergeFrom(const IMAllUserRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 latest_update_time = 2;
  inline bool has_latest_update_time() const;
  inline void clear_latest_update_time();
  static const int kLatestUpdateTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 latest_update_time() const;
  inline void set_latest_update_time(::google::protobuf::uint32 value);

  // repeated .IM.BaseDefine.UserInfo user_list = 3;
  inline int user_list_size() const;
  inline void clear_user_list();
  static const int kUserListFieldNumber = 3;
  inline const ::IM::BaseDefine::UserInfo& user_list(int index) const;
  inline ::IM::BaseDefine::UserInfo* mutable_user_list(int index);
  inline ::IM::BaseDefine::UserInfo* add_user_list();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserInfo >&
      user_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserInfo >*
      mutable_user_list();

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMAllUserRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_latest_update_time();
  inline void clear_has_latest_update_time();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 latest_update_time_;
  ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserInfo > user_list_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMAllUserRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMUsersStatReq : public ::google::protobuf::MessageLite {
 public:
  IMUsersStatReq();
  virtual ~IMUsersStatReq();

  IMUsersStatReq(const IMUsersStatReq& from);

  inline IMUsersStatReq& operator=(const IMUsersStatReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMUsersStatReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMUsersStatReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMUsersStatReq* other);

  // implements Message ----------------------------------------------

  IMUsersStatReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMUsersStatReq& from);
  void MergeFrom(const IMUsersStatReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // repeated uint32 user_id_list = 2;
  inline int user_id_list_size() const;
  inline void clear_user_id_list();
  static const int kUserIdListFieldNumber = 2;
  inline ::google::protobuf::uint32 user_id_list(int index) const;
  inline void set_user_id_list(int index, ::google::protobuf::uint32 value);
  inline void add_user_id_list(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      user_id_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_user_id_list();

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMUsersStatReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > user_id_list_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMUsersStatReq* default_instance_;
};
// -------------------------------------------------------------------

class IMUsersStatRsp : public ::google::protobuf::MessageLite {
 public:
  IMUsersStatRsp();
  virtual ~IMUsersStatRsp();

  IMUsersStatRsp(const IMUsersStatRsp& from);

  inline IMUsersStatRsp& operator=(const IMUsersStatRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMUsersStatRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMUsersStatRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMUsersStatRsp* other);

  // implements Message ----------------------------------------------

  IMUsersStatRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMUsersStatRsp& from);
  void MergeFrom(const IMUsersStatRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // repeated .IM.BaseDefine.UserStat user_stat_list = 2;
  inline int user_stat_list_size() const;
  inline void clear_user_stat_list();
  static const int kUserStatListFieldNumber = 2;
  inline const ::IM::BaseDefine::UserStat& user_stat_list(int index) const;
  inline ::IM::BaseDefine::UserStat* mutable_user_stat_list(int index);
  inline ::IM::BaseDefine::UserStat* add_user_stat_list();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserStat >&
      user_stat_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserStat >*
      mutable_user_stat_list();

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMUsersStatRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserStat > user_stat_list_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMUsersStatRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMChangeAvatarReq : public ::google::protobuf::MessageLite {
 public:
  IMChangeAvatarReq();
  virtual ~IMChangeAvatarReq();

  IMChangeAvatarReq(const IMChangeAvatarReq& from);

  inline IMChangeAvatarReq& operator=(const IMChangeAvatarReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMChangeAvatarReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMChangeAvatarReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMChangeAvatarReq* other);

  // implements Message ----------------------------------------------

  IMChangeAvatarReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMChangeAvatarReq& from);
  void MergeFrom(const IMChangeAvatarReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required string avatar_url = 2;
  inline bool has_avatar_url() const;
  inline void clear_avatar_url();
  static const int kAvatarUrlFieldNumber = 2;
  inline const ::std::string& avatar_url() const;
  inline void set_avatar_url(const ::std::string& value);
  inline void set_avatar_url(const char* value);
  inline void set_avatar_url(const char* value, size_t size);
  inline ::std::string* mutable_avatar_url();
  inline ::std::string* release_avatar_url();
  inline void set_allocated_avatar_url(::std::string* avatar_url);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMChangeAvatarReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_avatar_url();
  inline void clear_has_avatar_url();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* avatar_url_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMChangeAvatarReq* default_instance_;
};
// -------------------------------------------------------------------

class IMChangeAvatarRsp : public ::google::protobuf::MessageLite {
 public:
  IMChangeAvatarRsp();
  virtual ~IMChangeAvatarRsp();

  IMChangeAvatarRsp(const IMChangeAvatarRsp& from);

  inline IMChangeAvatarRsp& operator=(const IMChangeAvatarRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMChangeAvatarRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMChangeAvatarRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMChangeAvatarRsp* other);

  // implements Message ----------------------------------------------

  IMChangeAvatarRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMChangeAvatarRsp& from);
  void MergeFrom(const IMChangeAvatarRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 result_code = 2;
  inline bool has_result_code() const;
  inline void clear_result_code();
  static const int kResultCodeFieldNumber = 2;
  inline ::google::protobuf::uint32 result_code() const;
  inline void set_result_code(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMChangeAvatarRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_result_code();
  inline void clear_has_result_code();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 result_code_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMChangeAvatarRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMPCLoginStatusNotify : public ::google::protobuf::MessageLite {
 public:
  IMPCLoginStatusNotify();
  virtual ~IMPCLoginStatusNotify();

  IMPCLoginStatusNotify(const IMPCLoginStatusNotify& from);

  inline IMPCLoginStatusNotify& operator=(const IMPCLoginStatusNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMPCLoginStatusNotify& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMPCLoginStatusNotify* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMPCLoginStatusNotify* other);

  // implements Message ----------------------------------------------

  IMPCLoginStatusNotify* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMPCLoginStatusNotify& from);
  void MergeFrom(const IMPCLoginStatusNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required .IM.BaseDefine.UserStatType login_stat = 2;
  inline bool has_login_stat() const;
  inline void clear_login_stat();
  static const int kLoginStatFieldNumber = 2;
  inline ::IM::BaseDefine::UserStatType login_stat() const;
  inline void set_login_stat(::IM::BaseDefine::UserStatType value);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMPCLoginStatusNotify)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_login_stat();
  inline void clear_has_login_stat();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  int login_stat_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMPCLoginStatusNotify* default_instance_;
};
// -------------------------------------------------------------------

class IMRemoveSessionNotify : public ::google::protobuf::MessageLite {
 public:
  IMRemoveSessionNotify();
  virtual ~IMRemoveSessionNotify();

  IMRemoveSessionNotify(const IMRemoveSessionNotify& from);

  inline IMRemoveSessionNotify& operator=(const IMRemoveSessionNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMRemoveSessionNotify& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMRemoveSessionNotify* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMRemoveSessionNotify* other);

  // implements Message ----------------------------------------------

  IMRemoveSessionNotify* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMRemoveSessionNotify& from);
  void MergeFrom(const IMRemoveSessionNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required .IM.BaseDefine.SessionType session_type = 2;
  inline bool has_session_type() const;
  inline void clear_session_type();
  static const int kSessionTypeFieldNumber = 2;
  inline ::IM::BaseDefine::SessionType session_type() const;
  inline void set_session_type(::IM::BaseDefine::SessionType value);

  // required uint32 session_id = 3;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 3;
  inline ::google::protobuf::uint32 session_id() const;
  inline void set_session_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMRemoveSessionNotify)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_session_type();
  inline void clear_has_session_type();
  inline void set_has_session_id();
  inline void clear_has_session_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  int session_type_;
  ::google::protobuf::uint32 session_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMRemoveSessionNotify* default_instance_;
};
// -------------------------------------------------------------------

class IMDepartmentReq : public ::google::protobuf::MessageLite {
 public:
  IMDepartmentReq();
  virtual ~IMDepartmentReq();

  IMDepartmentReq(const IMDepartmentReq& from);

  inline IMDepartmentReq& operator=(const IMDepartmentReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMDepartmentReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMDepartmentReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMDepartmentReq* other);

  // implements Message ----------------------------------------------

  IMDepartmentReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMDepartmentReq& from);
  void MergeFrom(const IMDepartmentReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 latest_update_time = 2;
  inline bool has_latest_update_time() const;
  inline void clear_latest_update_time();
  static const int kLatestUpdateTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 latest_update_time() const;
  inline void set_latest_update_time(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMDepartmentReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_latest_update_time();
  inline void clear_has_latest_update_time();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 latest_update_time_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMDepartmentReq* default_instance_;
};
// -------------------------------------------------------------------

class IMDepartmentRsp : public ::google::protobuf::MessageLite {
 public:
  IMDepartmentRsp();
  virtual ~IMDepartmentRsp();

  IMDepartmentRsp(const IMDepartmentRsp& from);

  inline IMDepartmentRsp& operator=(const IMDepartmentRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMDepartmentRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMDepartmentRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMDepartmentRsp* other);

  // implements Message ----------------------------------------------

  IMDepartmentRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMDepartmentRsp& from);
  void MergeFrom(const IMDepartmentRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 latest_update_time = 2;
  inline bool has_latest_update_time() const;
  inline void clear_latest_update_time();
  static const int kLatestUpdateTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 latest_update_time() const;
  inline void set_latest_update_time(::google::protobuf::uint32 value);

  // repeated .IM.BaseDefine.DepartInfo dept_list = 3;
  inline int dept_list_size() const;
  inline void clear_dept_list();
  static const int kDeptListFieldNumber = 3;
  inline const ::IM::BaseDefine::DepartInfo& dept_list(int index) const;
  inline ::IM::BaseDefine::DepartInfo* mutable_dept_list(int index);
  inline ::IM::BaseDefine::DepartInfo* add_dept_list();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::DepartInfo >&
      dept_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::DepartInfo >*
      mutable_dept_list();

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMDepartmentRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_latest_update_time();
  inline void clear_has_latest_update_time();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 latest_update_time_;
  ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::DepartInfo > dept_list_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMDepartmentRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMAvatarChangedNotify : public ::google::protobuf::MessageLite {
 public:
  IMAvatarChangedNotify();
  virtual ~IMAvatarChangedNotify();

  IMAvatarChangedNotify(const IMAvatarChangedNotify& from);

  inline IMAvatarChangedNotify& operator=(const IMAvatarChangedNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMAvatarChangedNotify& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMAvatarChangedNotify* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMAvatarChangedNotify* other);

  // implements Message ----------------------------------------------

  IMAvatarChangedNotify* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMAvatarChangedNotify& from);
  void MergeFrom(const IMAvatarChangedNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 changed_user_id = 1;
  inline bool has_changed_user_id() const;
  inline void clear_changed_user_id();
  static const int kChangedUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 changed_user_id() const;
  inline void set_changed_user_id(::google::protobuf::uint32 value);

  // required string avatar_url = 2;
  inline bool has_avatar_url() const;
  inline void clear_avatar_url();
  static const int kAvatarUrlFieldNumber = 2;
  inline const ::std::string& avatar_url() const;
  inline void set_avatar_url(const ::std::string& value);
  inline void set_avatar_url(const char* value);
  inline void set_avatar_url(const char* value, size_t size);
  inline ::std::string* mutable_avatar_url();
  inline ::std::string* release_avatar_url();
  inline void set_allocated_avatar_url(::std::string* avatar_url);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMAvatarChangedNotify)
 private:
  inline void set_has_changed_user_id();
  inline void clear_has_changed_user_id();
  inline void set_has_avatar_url();
  inline void clear_has_avatar_url();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* avatar_url_;
  ::google::protobuf::uint32 changed_user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMAvatarChangedNotify* default_instance_;
};
// -------------------------------------------------------------------

class IMChangeSignInfoReq : public ::google::protobuf::MessageLite {
 public:
  IMChangeSignInfoReq();
  virtual ~IMChangeSignInfoReq();

  IMChangeSignInfoReq(const IMChangeSignInfoReq& from);

  inline IMChangeSignInfoReq& operator=(const IMChangeSignInfoReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMChangeSignInfoReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMChangeSignInfoReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMChangeSignInfoReq* other);

  // implements Message ----------------------------------------------

  IMChangeSignInfoReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMChangeSignInfoReq& from);
  void MergeFrom(const IMChangeSignInfoReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required string sign_info = 2;
  inline bool has_sign_info() const;
  inline void clear_sign_info();
  static const int kSignInfoFieldNumber = 2;
  inline const ::std::string& sign_info() const;
  inline void set_sign_info(const ::std::string& value);
  inline void set_sign_info(const char* value);
  inline void set_sign_info(const char* value, size_t size);
  inline ::std::string* mutable_sign_info();
  inline ::std::string* release_sign_info();
  inline void set_allocated_sign_info(::std::string* sign_info);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMChangeSignInfoReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_sign_info();
  inline void clear_has_sign_info();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* sign_info_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMChangeSignInfoReq* default_instance_;
};
// -------------------------------------------------------------------

class IMChangeSignInfoRsp : public ::google::protobuf::MessageLite {
 public:
  IMChangeSignInfoRsp();
  virtual ~IMChangeSignInfoRsp();

  IMChangeSignInfoRsp(const IMChangeSignInfoRsp& from);

  inline IMChangeSignInfoRsp& operator=(const IMChangeSignInfoRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMChangeSignInfoRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMChangeSignInfoRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMChangeSignInfoRsp* other);

  // implements Message ----------------------------------------------

  IMChangeSignInfoRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMChangeSignInfoRsp& from);
  void MergeFrom(const IMChangeSignInfoRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 result_code = 2;
  inline bool has_result_code() const;
  inline void clear_result_code();
  static const int kResultCodeFieldNumber = 2;
  inline ::google::protobuf::uint32 result_code() const;
  inline void set_result_code(::google::protobuf::uint32 value);

  // optional string sign_info = 3;
  inline bool has_sign_info() const;
  inline void clear_sign_info();
  static const int kSignInfoFieldNumber = 3;
  inline const ::std::string& sign_info() const;
  inline void set_sign_info(const ::std::string& value);
  inline void set_sign_info(const char* value);
  inline void set_sign_info(const char* value, size_t size);
  inline ::std::string* mutable_sign_info();
  inline ::std::string* release_sign_info();
  inline void set_allocated_sign_info(::std::string* sign_info);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMChangeSignInfoRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_result_code();
  inline void clear_has_result_code();
  inline void set_has_sign_info();
  inline void clear_has_sign_info();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 result_code_;
  ::std::string* sign_info_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMChangeSignInfoRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMSignInfoChangedNotify : public ::google::protobuf::MessageLite {
 public:
  IMSignInfoChangedNotify();
  virtual ~IMSignInfoChangedNotify();

  IMSignInfoChangedNotify(const IMSignInfoChangedNotify& from);

  inline IMSignInfoChangedNotify& operator=(const IMSignInfoChangedNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMSignInfoChangedNotify& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMSignInfoChangedNotify* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMSignInfoChangedNotify* other);

  // implements Message ----------------------------------------------

  IMSignInfoChangedNotify* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMSignInfoChangedNotify& from);
  void MergeFrom(const IMSignInfoChangedNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 changed_user_id = 1;
  inline bool has_changed_user_id() const;
  inline void clear_changed_user_id();
  static const int kChangedUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 changed_user_id() const;
  inline void set_changed_user_id(::google::protobuf::uint32 value);

  // required string sign_info = 2;
  inline bool has_sign_info() const;
  inline void clear_sign_info();
  static const int kSignInfoFieldNumber = 2;
  inline const ::std::string& sign_info() const;
  inline void set_sign_info(const ::std::string& value);
  inline void set_sign_info(const char* value);
  inline void set_sign_info(const char* value, size_t size);
  inline ::std::string* mutable_sign_info();
  inline ::std::string* release_sign_info();
  inline void set_allocated_sign_info(::std::string* sign_info);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMSignInfoChangedNotify)
 private:
  inline void set_has_changed_user_id();
  inline void clear_has_changed_user_id();
  inline void set_has_sign_info();
  inline void clear_has_sign_info();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* sign_info_;
  ::google::protobuf::uint32 changed_user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMSignInfoChangedNotify* default_instance_;
};
// -------------------------------------------------------------------

class TravelRouteReq : public ::google::protobuf::MessageLite {
 public:
  TravelRouteReq();
  virtual ~TravelRouteReq();

  TravelRouteReq(const TravelRouteReq& from);

  inline TravelRouteReq& operator=(const TravelRouteReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const TravelRouteReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TravelRouteReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TravelRouteReq* other);

  // implements Message ----------------------------------------------

  TravelRouteReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TravelRouteReq& from);
  void MergeFrom(const TravelRouteReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 travel_type = 2;
  inline bool has_travel_type() const;
  inline void clear_travel_type();
  static const int kTravelTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 travel_type() const;
  inline void set_travel_type(::google::protobuf::uint32 value);

  // required string lines = 3;
  inline bool has_lines() const;
  inline void clear_lines();
  static const int kLinesFieldNumber = 3;
  inline const ::std::string& lines() const;
  inline void set_lines(const ::std::string& value);
  inline void set_lines(const char* value);
  inline void set_lines(const char* value, size_t size);
  inline ::std::string* mutable_lines();
  inline ::std::string* release_lines();
  inline void set_allocated_lines(::std::string* lines);

  // required uint32 time_from = 4;
  inline bool has_time_from() const;
  inline void clear_time_from();
  static const int kTimeFromFieldNumber = 4;
  inline ::google::protobuf::uint32 time_from() const;
  inline void set_time_from(::google::protobuf::uint32 value);

  // required uint32 time_to = 5;
  inline bool has_time_to() const;
  inline void clear_time_to();
  static const int kTimeToFieldNumber = 5;
  inline ::google::protobuf::uint32 time_to() const;
  inline void set_time_to(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.TravelRouteReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_travel_type();
  inline void clear_has_travel_type();
  inline void set_has_lines();
  inline void clear_has_lines();
  inline void set_has_time_from();
  inline void clear_has_time_from();
  inline void set_has_time_to();
  inline void clear_has_time_to();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 travel_type_;
  ::std::string* lines_;
  ::google::protobuf::uint32 time_from_;
  ::google::protobuf::uint32 time_to_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static TravelRouteReq* default_instance_;
};
// -------------------------------------------------------------------

class TravelToolInfo : public ::google::protobuf::MessageLite {
 public:
  TravelToolInfo();
  virtual ~TravelToolInfo();

  TravelToolInfo(const TravelToolInfo& from);

  inline TravelToolInfo& operator=(const TravelToolInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const TravelToolInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TravelToolInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TravelToolInfo* other);

  // implements Message ----------------------------------------------

  TravelToolInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TravelToolInfo& from);
  void MergeFrom(const TravelToolInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 travel_type = 1;
  inline bool has_travel_type() const;
  inline void clear_travel_type();
  static const int kTravelTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 travel_type() const;
  inline void set_travel_type(::google::protobuf::uint32 value);

  // required string no = 2;
  inline bool has_no() const;
  inline void clear_no();
  static const int kNoFieldNumber = 2;
  inline const ::std::string& no() const;
  inline void set_no(const ::std::string& value);
  inline void set_no(const char* value);
  inline void set_no(const char* value, size_t size);
  inline ::std::string* mutable_no();
  inline ::std::string* release_no();
  inline void set_allocated_no(::std::string* no);

  // required string place_from_code = 3;
  inline bool has_place_from_code() const;
  inline void clear_place_from_code();
  static const int kPlaceFromCodeFieldNumber = 3;
  inline const ::std::string& place_from_code() const;
  inline void set_place_from_code(const ::std::string& value);
  inline void set_place_from_code(const char* value);
  inline void set_place_from_code(const char* value, size_t size);
  inline ::std::string* mutable_place_from_code();
  inline ::std::string* release_place_from_code();
  inline void set_allocated_place_from_code(::std::string* place_from_code);

  // required string place_from = 4;
  inline bool has_place_from() const;
  inline void clear_place_from();
  static const int kPlaceFromFieldNumber = 4;
  inline const ::std::string& place_from() const;
  inline void set_place_from(const ::std::string& value);
  inline void set_place_from(const char* value);
  inline void set_place_from(const char* value, size_t size);
  inline ::std::string* mutable_place_from();
  inline ::std::string* release_place_from();
  inline void set_allocated_place_from(::std::string* place_from);

  // required string place_to_code = 5;
  inline bool has_place_to_code() const;
  inline void clear_place_to_code();
  static const int kPlaceToCodeFieldNumber = 5;
  inline const ::std::string& place_to_code() const;
  inline void set_place_to_code(const ::std::string& value);
  inline void set_place_to_code(const char* value);
  inline void set_place_to_code(const char* value, size_t size);
  inline ::std::string* mutable_place_to_code();
  inline ::std::string* release_place_to_code();
  inline void set_allocated_place_to_code(::std::string* place_to_code);

  // required string place_to = 6;
  inline bool has_place_to() const;
  inline void clear_place_to();
  static const int kPlaceToFieldNumber = 6;
  inline const ::std::string& place_to() const;
  inline void set_place_to(const ::std::string& value);
  inline void set_place_to(const char* value);
  inline void set_place_to(const char* value, size_t size);
  inline ::std::string* mutable_place_to();
  inline ::std::string* release_place_to();
  inline void set_allocated_place_to(::std::string* place_to);

  // required string time_from = 7;
  inline bool has_time_from() const;
  inline void clear_time_from();
  static const int kTimeFromFieldNumber = 7;
  inline const ::std::string& time_from() const;
  inline void set_time_from(const ::std::string& value);
  inline void set_time_from(const char* value);
  inline void set_time_from(const char* value, size_t size);
  inline ::std::string* mutable_time_from();
  inline ::std::string* release_time_from();
  inline void set_allocated_time_from(::std::string* time_from);

  // required string time_to = 8;
  inline bool has_time_to() const;
  inline void clear_time_to();
  static const int kTimeToFieldNumber = 8;
  inline const ::std::string& time_to() const;
  inline void set_time_to(const ::std::string& value);
  inline void set_time_to(const char* value);
  inline void set_time_to(const char* value, size_t size);
  inline ::std::string* mutable_time_to();
  inline ::std::string* release_time_to();
  inline void set_allocated_time_to(::std::string* time_to);

  // required uint32 price = 9;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 9;
  inline ::google::protobuf::uint32 price() const;
  inline void set_price(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.Buddy.TravelToolInfo)
 private:
  inline void set_has_travel_type();
  inline void clear_has_travel_type();
  inline void set_has_no();
  inline void clear_has_no();
  inline void set_has_place_from_code();
  inline void clear_has_place_from_code();
  inline void set_has_place_from();
  inline void clear_has_place_from();
  inline void set_has_place_to_code();
  inline void clear_has_place_to_code();
  inline void set_has_place_to();
  inline void clear_has_place_to();
  inline void set_has_time_from();
  inline void clear_has_time_from();
  inline void set_has_time_to();
  inline void clear_has_time_to();
  inline void set_has_price();
  inline void clear_has_price();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* no_;
  ::std::string* place_from_code_;
  ::std::string* place_from_;
  ::std::string* place_to_code_;
  ::google::protobuf::uint32 travel_type_;
  ::google::protobuf::uint32 price_;
  ::std::string* place_to_;
  ::std::string* time_from_;
  ::std::string* time_to_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static TravelToolInfo* default_instance_;
};
// -------------------------------------------------------------------

class TravelRouteRsp : public ::google::protobuf::MessageLite {
 public:
  TravelRouteRsp();
  virtual ~TravelRouteRsp();

  TravelRouteRsp(const TravelRouteRsp& from);

  inline TravelRouteRsp& operator=(const TravelRouteRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const TravelRouteRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TravelRouteRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TravelRouteRsp* other);

  // implements Message ----------------------------------------------

  TravelRouteRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TravelRouteRsp& from);
  void MergeFrom(const TravelRouteRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 result_code = 2;
  inline bool has_result_code() const;
  inline void clear_result_code();
  static const int kResultCodeFieldNumber = 2;
  inline ::google::protobuf::uint32 result_code() const;
  inline void set_result_code(::google::protobuf::uint32 value);

  // repeated .IM.Buddy.TravelToolInfo travel_tool_info = 3;
  inline int travel_tool_info_size() const;
  inline void clear_travel_tool_info();
  static const int kTravelToolInfoFieldNumber = 3;
  inline const ::IM::Buddy::TravelToolInfo& travel_tool_info(int index) const;
  inline ::IM::Buddy::TravelToolInfo* mutable_travel_tool_info(int index);
  inline ::IM::Buddy::TravelToolInfo* add_travel_tool_info();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::Buddy::TravelToolInfo >&
      travel_tool_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::Buddy::TravelToolInfo >*
      mutable_travel_tool_info();

  // @@protoc_insertion_point(class_scope:IM.Buddy.TravelRouteRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_result_code();
  inline void clear_has_result_code();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 result_code_;
  ::google::protobuf::RepeatedPtrField< ::IM::Buddy::TravelToolInfo > travel_tool_info_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static TravelRouteRsp* default_instance_;
};
// -------------------------------------------------------------------

class TravelInfo : public ::google::protobuf::MessageLite {
 public:
  TravelInfo();
  virtual ~TravelInfo();

  TravelInfo(const TravelInfo& from);

  inline TravelInfo& operator=(const TravelInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const TravelInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TravelInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TravelInfo* other);

  // implements Message ----------------------------------------------

  TravelInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TravelInfo& from);
  void MergeFrom(const TravelInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 person_num = 1;
  inline bool has_person_num() const;
  inline void clear_person_num();
  static const int kPersonNumFieldNumber = 1;
  inline ::google::protobuf::uint32 person_num() const;
  inline void set_person_num(::google::protobuf::uint32 value);

  // required string place_from = 2;
  inline bool has_place_from() const;
  inline void clear_place_from();
  static const int kPlaceFromFieldNumber = 2;
  inline const ::std::string& place_from() const;
  inline void set_place_from(const ::std::string& value);
  inline void set_place_from(const char* value);
  inline void set_place_from(const char* value, size_t size);
  inline ::std::string* mutable_place_from();
  inline ::std::string* release_place_from();
  inline void set_allocated_place_from(::std::string* place_from);

  // required string place_back = 3;
  inline bool has_place_back() const;
  inline void clear_place_back();
  static const int kPlaceBackFieldNumber = 3;
  inline const ::std::string& place_back() const;
  inline void set_place_back(const ::std::string& value);
  inline void set_place_back(const char* value);
  inline void set_place_back(const char* value, size_t size);
  inline ::std::string* mutable_place_back();
  inline ::std::string* release_place_back();
  inline void set_allocated_place_back(::std::string* place_back);

  // required string place_to = 4;
  inline bool has_place_to() const;
  inline void clear_place_to();
  static const int kPlaceToFieldNumber = 4;
  inline const ::std::string& place_to() const;
  inline void set_place_to(const ::std::string& value);
  inline void set_place_to(const char* value);
  inline void set_place_to(const char* value, size_t size);
  inline ::std::string* mutable_place_to();
  inline ::std::string* release_place_to();
  inline void set_allocated_place_to(::std::string* place_to);

  // required string date_from = 5;
  inline bool has_date_from() const;
  inline void clear_date_from();
  static const int kDateFromFieldNumber = 5;
  inline const ::std::string& date_from() const;
  inline void set_date_from(const ::std::string& value);
  inline void set_date_from(const char* value);
  inline void set_date_from(const char* value, size_t size);
  inline ::std::string* mutable_date_from();
  inline ::std::string* release_date_from();
  inline void set_allocated_date_from(::std::string* date_from);

  // required string date_to = 6;
  inline bool has_date_to() const;
  inline void clear_date_to();
  static const int kDateToFieldNumber = 6;
  inline const ::std::string& date_to() const;
  inline void set_date_to(const ::std::string& value);
  inline void set_date_to(const char* value);
  inline void set_date_to(const char* value, size_t size);
  inline ::std::string* mutable_date_to();
  inline ::std::string* release_date_to();
  inline void set_allocated_date_to(::std::string* date_to);

  // @@protoc_insertion_point(class_scope:IM.Buddy.TravelInfo)
 private:
  inline void set_has_person_num();
  inline void clear_has_person_num();
  inline void set_has_place_from();
  inline void clear_has_place_from();
  inline void set_has_place_back();
  inline void clear_has_place_back();
  inline void set_has_place_to();
  inline void clear_has_place_to();
  inline void set_has_date_from();
  inline void clear_has_date_from();
  inline void set_has_date_to();
  inline void clear_has_date_to();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* place_from_;
  ::std::string* place_back_;
  ::std::string* place_to_;
  ::std::string* date_from_;
  ::std::string* date_to_;
  ::google::protobuf::uint32 person_num_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static TravelInfo* default_instance_;
};
// -------------------------------------------------------------------

class TrafficInfo : public ::google::protobuf::MessageLite {
 public:
  TrafficInfo();
  virtual ~TrafficInfo();

  TrafficInfo(const TrafficInfo& from);

  inline TrafficInfo& operator=(const TrafficInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const TrafficInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TrafficInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TrafficInfo* other);

  // implements Message ----------------------------------------------

  TrafficInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TrafficInfo& from);
  void MergeFrom(const TrafficInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string traffic_time_from = 1;
  inline bool has_traffic_time_from() const;
  inline void clear_traffic_time_from();
  static const int kTrafficTimeFromFieldNumber = 1;
  inline const ::std::string& traffic_time_from() const;
  inline void set_traffic_time_from(const ::std::string& value);
  inline void set_traffic_time_from(const char* value);
  inline void set_traffic_time_from(const char* value, size_t size);
  inline ::std::string* mutable_traffic_time_from();
  inline ::std::string* release_traffic_time_from();
  inline void set_allocated_traffic_time_from(::std::string* traffic_time_from);

  // required string traffic_time_to = 2;
  inline bool has_traffic_time_to() const;
  inline void clear_traffic_time_to();
  static const int kTrafficTimeToFieldNumber = 2;
  inline const ::std::string& traffic_time_to() const;
  inline void set_traffic_time_to(const ::std::string& value);
  inline void set_traffic_time_to(const char* value);
  inline void set_traffic_time_to(const char* value, size_t size);
  inline ::std::string* mutable_traffic_time_to();
  inline ::std::string* release_traffic_time_to();
  inline void set_allocated_traffic_time_to(::std::string* traffic_time_to);

  // required uint32 travel_type = 3;
  inline bool has_travel_type() const;
  inline void clear_travel_type();
  static const int kTravelTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 travel_type() const;
  inline void set_travel_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.Buddy.TrafficInfo)
 private:
  inline void set_has_traffic_time_from();
  inline void clear_has_traffic_time_from();
  inline void set_has_traffic_time_to();
  inline void clear_has_traffic_time_to();
  inline void set_has_travel_type();
  inline void clear_has_travel_type();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* traffic_time_from_;
  ::std::string* traffic_time_to_;
  ::google::protobuf::uint32 travel_type_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static TrafficInfo* default_instance_;
};
// -------------------------------------------------------------------

class PlayInfo : public ::google::protobuf::MessageLite {
 public:
  PlayInfo();
  virtual ~PlayInfo();

  PlayInfo(const PlayInfo& from);

  inline PlayInfo& operator=(const PlayInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const PlayInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PlayInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PlayInfo* other);

  // implements Message ----------------------------------------------

  PlayInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlayInfo& from);
  void MergeFrom(const PlayInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .IM.Buddy.PlayQualityType play_quality = 1;
  inline bool has_play_quality() const;
  inline void clear_play_quality();
  static const int kPlayQualityFieldNumber = 1;
  inline ::IM::Buddy::PlayQualityType play_quality() const;
  inline void set_play_quality(::IM::Buddy::PlayQualityType value);

  // required string play_time_from = 2;
  inline bool has_play_time_from() const;
  inline void clear_play_time_from();
  static const int kPlayTimeFromFieldNumber = 2;
  inline const ::std::string& play_time_from() const;
  inline void set_play_time_from(const ::std::string& value);
  inline void set_play_time_from(const char* value);
  inline void set_play_time_from(const char* value, size_t size);
  inline ::std::string* mutable_play_time_from();
  inline ::std::string* release_play_time_from();
  inline void set_allocated_play_time_from(::std::string* play_time_from);

  // required string play_time_to = 3;
  inline bool has_play_time_to() const;
  inline void clear_play_time_to();
  static const int kPlayTimeToFieldNumber = 3;
  inline const ::std::string& play_time_to() const;
  inline void set_play_time_to(const ::std::string& value);
  inline void set_play_time_to(const char* value);
  inline void set_play_time_to(const char* value, size_t size);
  inline ::std::string* mutable_play_time_to();
  inline ::std::string* release_play_time_to();
  inline void set_allocated_play_time_to(::std::string* play_time_to);

  // required uint32 city_traffic = 4;
  inline bool has_city_traffic() const;
  inline void clear_city_traffic();
  static const int kCityTrafficFieldNumber = 4;
  inline ::google::protobuf::uint32 city_traffic() const;
  inline void set_city_traffic(::google::protobuf::uint32 value);

  // required .IM.Buddy.HotelPositionType hotel_position = 5;
  inline bool has_hotel_position() const;
  inline void clear_hotel_position();
  static const int kHotelPositionFieldNumber = 5;
  inline ::IM::Buddy::HotelPositionType hotel_position() const;
  inline void set_hotel_position(::IM::Buddy::HotelPositionType value);

  // @@protoc_insertion_point(class_scope:IM.Buddy.PlayInfo)
 private:
  inline void set_has_play_quality();
  inline void clear_has_play_quality();
  inline void set_has_play_time_from();
  inline void clear_has_play_time_from();
  inline void set_has_play_time_to();
  inline void clear_has_play_time_to();
  inline void set_has_city_traffic();
  inline void clear_has_city_traffic();
  inline void set_has_hotel_position();
  inline void clear_has_hotel_position();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* play_time_from_;
  int play_quality_;
  ::google::protobuf::uint32 city_traffic_;
  ::std::string* play_time_to_;
  int hotel_position_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static PlayInfo* default_instance_;
};
// -------------------------------------------------------------------

class TravelDetail : public ::google::protobuf::MessageLite {
 public:
  TravelDetail();
  virtual ~TravelDetail();

  TravelDetail(const TravelDetail& from);

  inline TravelDetail& operator=(const TravelDetail& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const TravelDetail& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TravelDetail* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TravelDetail* other);

  // implements Message ----------------------------------------------

  TravelDetail* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TravelDetail& from);
  void MergeFrom(const TravelDetail& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 db_idx = 1;
  inline bool has_db_idx() const;
  inline void clear_db_idx();
  static const int kDbIdxFieldNumber = 1;
  inline ::google::protobuf::uint32 db_idx() const;
  inline void set_db_idx(::google::protobuf::uint32 value);

  // required .IM.Buddy.TravelInfo travel_info = 2;
  inline bool has_travel_info() const;
  inline void clear_travel_info();
  static const int kTravelInfoFieldNumber = 2;
  inline const ::IM::Buddy::TravelInfo& travel_info() const;
  inline ::IM::Buddy::TravelInfo* mutable_travel_info();
  inline ::IM::Buddy::TravelInfo* release_travel_info();
  inline void set_allocated_travel_info(::IM::Buddy::TravelInfo* travel_info);

  // required .IM.Buddy.TrafficInfo traffic_info = 3;
  inline bool has_traffic_info() const;
  inline void clear_traffic_info();
  static const int kTrafficInfoFieldNumber = 3;
  inline const ::IM::Buddy::TrafficInfo& traffic_info() const;
  inline ::IM::Buddy::TrafficInfo* mutable_traffic_info();
  inline ::IM::Buddy::TrafficInfo* release_traffic_info();
  inline void set_allocated_traffic_info(::IM::Buddy::TrafficInfo* traffic_info);

  // required .IM.Buddy.PlayInfo play_info = 4;
  inline bool has_play_info() const;
  inline void clear_play_info();
  static const int kPlayInfoFieldNumber = 4;
  inline const ::IM::Buddy::PlayInfo& play_info() const;
  inline ::IM::Buddy::PlayInfo* mutable_play_info();
  inline ::IM::Buddy::PlayInfo* release_play_info();
  inline void set_allocated_play_info(::IM::Buddy::PlayInfo* play_info);

  // required uint32 cost = 5;
  inline bool has_cost() const;
  inline void clear_cost();
  static const int kCostFieldNumber = 5;
  inline ::google::protobuf::uint32 cost() const;
  inline void set_cost(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.Buddy.TravelDetail)
 private:
  inline void set_has_db_idx();
  inline void clear_has_db_idx();
  inline void set_has_travel_info();
  inline void clear_has_travel_info();
  inline void set_has_traffic_info();
  inline void clear_has_traffic_info();
  inline void set_has_play_info();
  inline void clear_has_play_info();
  inline void set_has_cost();
  inline void clear_has_cost();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::IM::Buddy::TravelInfo* travel_info_;
  ::IM::Buddy::TrafficInfo* traffic_info_;
  ::google::protobuf::uint32 db_idx_;
  ::google::protobuf::uint32 cost_;
  ::IM::Buddy::PlayInfo* play_info_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static TravelDetail* default_instance_;
};
// -------------------------------------------------------------------

class GetTravelListReq : public ::google::protobuf::MessageLite {
 public:
  GetTravelListReq();
  virtual ~GetTravelListReq();

  GetTravelListReq(const GetTravelListReq& from);

  inline GetTravelListReq& operator=(const GetTravelListReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetTravelListReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetTravelListReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetTravelListReq* other);

  // implements Message ----------------------------------------------

  GetTravelListReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetTravelListReq& from);
  void MergeFrom(const GetTravelListReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.GetTravelListReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static GetTravelListReq* default_instance_;
};
// -------------------------------------------------------------------

class GetTravelTripListRsp : public ::google::protobuf::MessageLite {
 public:
  GetTravelTripListRsp();
  virtual ~GetTravelTripListRsp();

  GetTravelTripListRsp(const GetTravelTripListRsp& from);

  inline GetTravelTripListRsp& operator=(const GetTravelTripListRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetTravelTripListRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetTravelTripListRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetTravelTripListRsp* other);

  // implements Message ----------------------------------------------

  GetTravelTripListRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetTravelTripListRsp& from);
  void MergeFrom(const GetTravelTripListRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 result_code = 2;
  inline bool has_result_code() const;
  inline void clear_result_code();
  static const int kResultCodeFieldNumber = 2;
  inline ::google::protobuf::uint32 result_code() const;
  inline void set_result_code(::google::protobuf::uint32 value);

  // repeated .IM.Buddy.TravelDetail travel_detail = 3;
  inline int travel_detail_size() const;
  inline void clear_travel_detail();
  static const int kTravelDetailFieldNumber = 3;
  inline const ::IM::Buddy::TravelDetail& travel_detail(int index) const;
  inline ::IM::Buddy::TravelDetail* mutable_travel_detail(int index);
  inline ::IM::Buddy::TravelDetail* add_travel_detail();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::Buddy::TravelDetail >&
      travel_detail() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::Buddy::TravelDetail >*
      mutable_travel_detail();

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.GetTravelTripListRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_result_code();
  inline void clear_has_result_code();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 result_code_;
  ::google::protobuf::RepeatedPtrField< ::IM::Buddy::TravelDetail > travel_detail_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static GetTravelTripListRsp* default_instance_;
};
// -------------------------------------------------------------------

class CreateTravelReq : public ::google::protobuf::MessageLite {
 public:
  CreateTravelReq();
  virtual ~CreateTravelReq();

  CreateTravelReq(const CreateTravelReq& from);

  inline CreateTravelReq& operator=(const CreateTravelReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CreateTravelReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CreateTravelReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CreateTravelReq* other);

  // implements Message ----------------------------------------------

  CreateTravelReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CreateTravelReq& from);
  void MergeFrom(const CreateTravelReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required .IM.Buddy.TravelDetail travel_detail = 2;
  inline bool has_travel_detail() const;
  inline void clear_travel_detail();
  static const int kTravelDetailFieldNumber = 2;
  inline const ::IM::Buddy::TravelDetail& travel_detail() const;
  inline ::IM::Buddy::TravelDetail* mutable_travel_detail();
  inline ::IM::Buddy::TravelDetail* release_travel_detail();
  inline void set_allocated_travel_detail(::IM::Buddy::TravelDetail* travel_detail);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.CreateTravelReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_travel_detail();
  inline void clear_has_travel_detail();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::IM::Buddy::TravelDetail* travel_detail_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static CreateTravelReq* default_instance_;
};
// -------------------------------------------------------------------

class CreateTravelRsp : public ::google::protobuf::MessageLite {
 public:
  CreateTravelRsp();
  virtual ~CreateTravelRsp();

  CreateTravelRsp(const CreateTravelRsp& from);

  inline CreateTravelRsp& operator=(const CreateTravelRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CreateTravelRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CreateTravelRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CreateTravelRsp* other);

  // implements Message ----------------------------------------------

  CreateTravelRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CreateTravelRsp& from);
  void MergeFrom(const CreateTravelRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 result_code = 2;
  inline bool has_result_code() const;
  inline void clear_result_code();
  static const int kResultCodeFieldNumber = 2;
  inline ::google::protobuf::uint32 result_code() const;
  inline void set_result_code(::google::protobuf::uint32 value);

  // required uint32 db_idx = 3;
  inline bool has_db_idx() const;
  inline void clear_db_idx();
  static const int kDbIdxFieldNumber = 3;
  inline ::google::protobuf::uint32 db_idx() const;
  inline void set_db_idx(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.CreateTravelRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_result_code();
  inline void clear_has_result_code();
  inline void set_has_db_idx();
  inline void clear_has_db_idx();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 result_code_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 db_idx_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static CreateTravelRsp* default_instance_;
};
// ===================================================================


// ===================================================================

// IMRecentContactSessionReq

// required uint32 user_id = 1;
inline bool IMRecentContactSessionReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMRecentContactSessionReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMRecentContactSessionReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMRecentContactSessionReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMRecentContactSessionReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRecentContactSessionReq.user_id)
  return user_id_;
}
inline void IMRecentContactSessionReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRecentContactSessionReq.user_id)
}

// required uint32 latest_update_time = 2;
inline bool IMRecentContactSessionReq::has_latest_update_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMRecentContactSessionReq::set_has_latest_update_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMRecentContactSessionReq::clear_has_latest_update_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMRecentContactSessionReq::clear_latest_update_time() {
  latest_update_time_ = 0u;
  clear_has_latest_update_time();
}
inline ::google::protobuf::uint32 IMRecentContactSessionReq::latest_update_time() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRecentContactSessionReq.latest_update_time)
  return latest_update_time_;
}
inline void IMRecentContactSessionReq::set_latest_update_time(::google::protobuf::uint32 value) {
  set_has_latest_update_time();
  latest_update_time_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRecentContactSessionReq.latest_update_time)
}

// optional bytes attach_data = 20;
inline bool IMRecentContactSessionReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMRecentContactSessionReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMRecentContactSessionReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMRecentContactSessionReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMRecentContactSessionReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRecentContactSessionReq.attach_data)
  return *attach_data_;
}
inline void IMRecentContactSessionReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRecentContactSessionReq.attach_data)
}
inline void IMRecentContactSessionReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMRecentContactSessionReq.attach_data)
}
inline void IMRecentContactSessionReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMRecentContactSessionReq.attach_data)
}
inline ::std::string* IMRecentContactSessionReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMRecentContactSessionReq.attach_data)
  return attach_data_;
}
inline ::std::string* IMRecentContactSessionReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMRecentContactSessionReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMRecentContactSessionReq.attach_data)
}

// -------------------------------------------------------------------

// IMRecentContactSessionRsp

// required uint32 user_id = 1;
inline bool IMRecentContactSessionRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMRecentContactSessionRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMRecentContactSessionRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMRecentContactSessionRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMRecentContactSessionRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRecentContactSessionRsp.user_id)
  return user_id_;
}
inline void IMRecentContactSessionRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRecentContactSessionRsp.user_id)
}

// repeated .IM.BaseDefine.ContactSessionInfo contact_session_list = 2;
inline int IMRecentContactSessionRsp::contact_session_list_size() const {
  return contact_session_list_.size();
}
inline void IMRecentContactSessionRsp::clear_contact_session_list() {
  contact_session_list_.Clear();
}
inline const ::IM::BaseDefine::ContactSessionInfo& IMRecentContactSessionRsp::contact_session_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRecentContactSessionRsp.contact_session_list)
  return contact_session_list_.Get(index);
}
inline ::IM::BaseDefine::ContactSessionInfo* IMRecentContactSessionRsp::mutable_contact_session_list(int index) {
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMRecentContactSessionRsp.contact_session_list)
  return contact_session_list_.Mutable(index);
}
inline ::IM::BaseDefine::ContactSessionInfo* IMRecentContactSessionRsp::add_contact_session_list() {
  // @@protoc_insertion_point(field_add:IM.Buddy.IMRecentContactSessionRsp.contact_session_list)
  return contact_session_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::ContactSessionInfo >&
IMRecentContactSessionRsp::contact_session_list() const {
  // @@protoc_insertion_point(field_list:IM.Buddy.IMRecentContactSessionRsp.contact_session_list)
  return contact_session_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::ContactSessionInfo >*
IMRecentContactSessionRsp::mutable_contact_session_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.Buddy.IMRecentContactSessionRsp.contact_session_list)
  return &contact_session_list_;
}

// optional bytes attach_data = 20;
inline bool IMRecentContactSessionRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMRecentContactSessionRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMRecentContactSessionRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMRecentContactSessionRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMRecentContactSessionRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRecentContactSessionRsp.attach_data)
  return *attach_data_;
}
inline void IMRecentContactSessionRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRecentContactSessionRsp.attach_data)
}
inline void IMRecentContactSessionRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMRecentContactSessionRsp.attach_data)
}
inline void IMRecentContactSessionRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMRecentContactSessionRsp.attach_data)
}
inline ::std::string* IMRecentContactSessionRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMRecentContactSessionRsp.attach_data)
  return attach_data_;
}
inline ::std::string* IMRecentContactSessionRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMRecentContactSessionRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMRecentContactSessionRsp.attach_data)
}

// -------------------------------------------------------------------

// IMUserStatNotify

// required .IM.BaseDefine.UserStat user_stat = 1;
inline bool IMUserStatNotify::has_user_stat() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMUserStatNotify::set_has_user_stat() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMUserStatNotify::clear_has_user_stat() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMUserStatNotify::clear_user_stat() {
  if (user_stat_ != NULL) user_stat_->::IM::BaseDefine::UserStat::Clear();
  clear_has_user_stat();
}
inline const ::IM::BaseDefine::UserStat& IMUserStatNotify::user_stat() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserStatNotify.user_stat)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_stat_ != NULL ? *user_stat_ : *default_instance().user_stat_;
#else
  return user_stat_ != NULL ? *user_stat_ : *default_instance_->user_stat_;
#endif
}
inline ::IM::BaseDefine::UserStat* IMUserStatNotify::mutable_user_stat() {
  set_has_user_stat();
  if (user_stat_ == NULL) user_stat_ = new ::IM::BaseDefine::UserStat;
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMUserStatNotify.user_stat)
  return user_stat_;
}
inline ::IM::BaseDefine::UserStat* IMUserStatNotify::release_user_stat() {
  clear_has_user_stat();
  ::IM::BaseDefine::UserStat* temp = user_stat_;
  user_stat_ = NULL;
  return temp;
}
inline void IMUserStatNotify::set_allocated_user_stat(::IM::BaseDefine::UserStat* user_stat) {
  delete user_stat_;
  user_stat_ = user_stat;
  if (user_stat) {
    set_has_user_stat();
  } else {
    clear_has_user_stat();
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMUserStatNotify.user_stat)
}

// -------------------------------------------------------------------

// IMUsersInfoReq

// required uint32 user_id = 1;
inline bool IMUsersInfoReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMUsersInfoReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMUsersInfoReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMUsersInfoReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMUsersInfoReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUsersInfoReq.user_id)
  return user_id_;
}
inline void IMUsersInfoReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUsersInfoReq.user_id)
}

// repeated uint32 user_id_list = 2;
inline int IMUsersInfoReq::user_id_list_size() const {
  return user_id_list_.size();
}
inline void IMUsersInfoReq::clear_user_id_list() {
  user_id_list_.Clear();
}
inline ::google::protobuf::uint32 IMUsersInfoReq::user_id_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUsersInfoReq.user_id_list)
  return user_id_list_.Get(index);
}
inline void IMUsersInfoReq::set_user_id_list(int index, ::google::protobuf::uint32 value) {
  user_id_list_.Set(index, value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUsersInfoReq.user_id_list)
}
inline void IMUsersInfoReq::add_user_id_list(::google::protobuf::uint32 value) {
  user_id_list_.Add(value);
  // @@protoc_insertion_point(field_add:IM.Buddy.IMUsersInfoReq.user_id_list)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
IMUsersInfoReq::user_id_list() const {
  // @@protoc_insertion_point(field_list:IM.Buddy.IMUsersInfoReq.user_id_list)
  return user_id_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
IMUsersInfoReq::mutable_user_id_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.Buddy.IMUsersInfoReq.user_id_list)
  return &user_id_list_;
}

// optional bytes attach_data = 20;
inline bool IMUsersInfoReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMUsersInfoReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMUsersInfoReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMUsersInfoReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMUsersInfoReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUsersInfoReq.attach_data)
  return *attach_data_;
}
inline void IMUsersInfoReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUsersInfoReq.attach_data)
}
inline void IMUsersInfoReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMUsersInfoReq.attach_data)
}
inline void IMUsersInfoReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMUsersInfoReq.attach_data)
}
inline ::std::string* IMUsersInfoReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMUsersInfoReq.attach_data)
  return attach_data_;
}
inline ::std::string* IMUsersInfoReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMUsersInfoReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMUsersInfoReq.attach_data)
}

// -------------------------------------------------------------------

// IMUsersInfoRsp

// required uint32 user_id = 1;
inline bool IMUsersInfoRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMUsersInfoRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMUsersInfoRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMUsersInfoRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMUsersInfoRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUsersInfoRsp.user_id)
  return user_id_;
}
inline void IMUsersInfoRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUsersInfoRsp.user_id)
}

// repeated .IM.BaseDefine.UserInfo user_info_list = 2;
inline int IMUsersInfoRsp::user_info_list_size() const {
  return user_info_list_.size();
}
inline void IMUsersInfoRsp::clear_user_info_list() {
  user_info_list_.Clear();
}
inline const ::IM::BaseDefine::UserInfo& IMUsersInfoRsp::user_info_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUsersInfoRsp.user_info_list)
  return user_info_list_.Get(index);
}
inline ::IM::BaseDefine::UserInfo* IMUsersInfoRsp::mutable_user_info_list(int index) {
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMUsersInfoRsp.user_info_list)
  return user_info_list_.Mutable(index);
}
inline ::IM::BaseDefine::UserInfo* IMUsersInfoRsp::add_user_info_list() {
  // @@protoc_insertion_point(field_add:IM.Buddy.IMUsersInfoRsp.user_info_list)
  return user_info_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserInfo >&
IMUsersInfoRsp::user_info_list() const {
  // @@protoc_insertion_point(field_list:IM.Buddy.IMUsersInfoRsp.user_info_list)
  return user_info_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserInfo >*
IMUsersInfoRsp::mutable_user_info_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.Buddy.IMUsersInfoRsp.user_info_list)
  return &user_info_list_;
}

// optional bytes attach_data = 20;
inline bool IMUsersInfoRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMUsersInfoRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMUsersInfoRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMUsersInfoRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMUsersInfoRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUsersInfoRsp.attach_data)
  return *attach_data_;
}
inline void IMUsersInfoRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUsersInfoRsp.attach_data)
}
inline void IMUsersInfoRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMUsersInfoRsp.attach_data)
}
inline void IMUsersInfoRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMUsersInfoRsp.attach_data)
}
inline ::std::string* IMUsersInfoRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMUsersInfoRsp.attach_data)
  return attach_data_;
}
inline ::std::string* IMUsersInfoRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMUsersInfoRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMUsersInfoRsp.attach_data)
}

// -------------------------------------------------------------------

// IMRemoveSessionReq

// required uint32 user_id = 1;
inline bool IMRemoveSessionReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMRemoveSessionReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMRemoveSessionReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMRemoveSessionReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMRemoveSessionReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRemoveSessionReq.user_id)
  return user_id_;
}
inline void IMRemoveSessionReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRemoveSessionReq.user_id)
}

// required .IM.BaseDefine.SessionType session_type = 2;
inline bool IMRemoveSessionReq::has_session_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMRemoveSessionReq::set_has_session_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMRemoveSessionReq::clear_has_session_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMRemoveSessionReq::clear_session_type() {
  session_type_ = 1;
  clear_has_session_type();
}
inline ::IM::BaseDefine::SessionType IMRemoveSessionReq::session_type() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRemoveSessionReq.session_type)
  return static_cast< ::IM::BaseDefine::SessionType >(session_type_);
}
inline void IMRemoveSessionReq::set_session_type(::IM::BaseDefine::SessionType value) {
  assert(::IM::BaseDefine::SessionType_IsValid(value));
  set_has_session_type();
  session_type_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRemoveSessionReq.session_type)
}

// required uint32 session_id = 3;
inline bool IMRemoveSessionReq::has_session_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMRemoveSessionReq::set_has_session_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMRemoveSessionReq::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMRemoveSessionReq::clear_session_id() {
  session_id_ = 0u;
  clear_has_session_id();
}
inline ::google::protobuf::uint32 IMRemoveSessionReq::session_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRemoveSessionReq.session_id)
  return session_id_;
}
inline void IMRemoveSessionReq::set_session_id(::google::protobuf::uint32 value) {
  set_has_session_id();
  session_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRemoveSessionReq.session_id)
}

// optional bytes attach_data = 20;
inline bool IMRemoveSessionReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMRemoveSessionReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMRemoveSessionReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMRemoveSessionReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMRemoveSessionReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRemoveSessionReq.attach_data)
  return *attach_data_;
}
inline void IMRemoveSessionReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRemoveSessionReq.attach_data)
}
inline void IMRemoveSessionReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMRemoveSessionReq.attach_data)
}
inline void IMRemoveSessionReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMRemoveSessionReq.attach_data)
}
inline ::std::string* IMRemoveSessionReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMRemoveSessionReq.attach_data)
  return attach_data_;
}
inline ::std::string* IMRemoveSessionReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMRemoveSessionReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMRemoveSessionReq.attach_data)
}

// -------------------------------------------------------------------

// IMRemoveSessionRsp

// required uint32 user_id = 1;
inline bool IMRemoveSessionRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMRemoveSessionRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMRemoveSessionRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMRemoveSessionRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMRemoveSessionRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRemoveSessionRsp.user_id)
  return user_id_;
}
inline void IMRemoveSessionRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRemoveSessionRsp.user_id)
}

// required uint32 result_code = 2;
inline bool IMRemoveSessionRsp::has_result_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMRemoveSessionRsp::set_has_result_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMRemoveSessionRsp::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMRemoveSessionRsp::clear_result_code() {
  result_code_ = 0u;
  clear_has_result_code();
}
inline ::google::protobuf::uint32 IMRemoveSessionRsp::result_code() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRemoveSessionRsp.result_code)
  return result_code_;
}
inline void IMRemoveSessionRsp::set_result_code(::google::protobuf::uint32 value) {
  set_has_result_code();
  result_code_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRemoveSessionRsp.result_code)
}

// required .IM.BaseDefine.SessionType session_type = 3;
inline bool IMRemoveSessionRsp::has_session_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMRemoveSessionRsp::set_has_session_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMRemoveSessionRsp::clear_has_session_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMRemoveSessionRsp::clear_session_type() {
  session_type_ = 1;
  clear_has_session_type();
}
inline ::IM::BaseDefine::SessionType IMRemoveSessionRsp::session_type() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRemoveSessionRsp.session_type)
  return static_cast< ::IM::BaseDefine::SessionType >(session_type_);
}
inline void IMRemoveSessionRsp::set_session_type(::IM::BaseDefine::SessionType value) {
  assert(::IM::BaseDefine::SessionType_IsValid(value));
  set_has_session_type();
  session_type_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRemoveSessionRsp.session_type)
}

// required uint32 session_id = 4;
inline bool IMRemoveSessionRsp::has_session_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMRemoveSessionRsp::set_has_session_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMRemoveSessionRsp::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMRemoveSessionRsp::clear_session_id() {
  session_id_ = 0u;
  clear_has_session_id();
}
inline ::google::protobuf::uint32 IMRemoveSessionRsp::session_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRemoveSessionRsp.session_id)
  return session_id_;
}
inline void IMRemoveSessionRsp::set_session_id(::google::protobuf::uint32 value) {
  set_has_session_id();
  session_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRemoveSessionRsp.session_id)
}

// optional bytes attach_data = 20;
inline bool IMRemoveSessionRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IMRemoveSessionRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IMRemoveSessionRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IMRemoveSessionRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMRemoveSessionRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRemoveSessionRsp.attach_data)
  return *attach_data_;
}
inline void IMRemoveSessionRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRemoveSessionRsp.attach_data)
}
inline void IMRemoveSessionRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMRemoveSessionRsp.attach_data)
}
inline void IMRemoveSessionRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMRemoveSessionRsp.attach_data)
}
inline ::std::string* IMRemoveSessionRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMRemoveSessionRsp.attach_data)
  return attach_data_;
}
inline ::std::string* IMRemoveSessionRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMRemoveSessionRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMRemoveSessionRsp.attach_data)
}

// -------------------------------------------------------------------

// IMAllUserReq

// required uint32 user_id = 1;
inline bool IMAllUserReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMAllUserReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMAllUserReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMAllUserReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMAllUserReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMAllUserReq.user_id)
  return user_id_;
}
inline void IMAllUserReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMAllUserReq.user_id)
}

// required uint32 latest_update_time = 2;
inline bool IMAllUserReq::has_latest_update_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMAllUserReq::set_has_latest_update_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMAllUserReq::clear_has_latest_update_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMAllUserReq::clear_latest_update_time() {
  latest_update_time_ = 0u;
  clear_has_latest_update_time();
}
inline ::google::protobuf::uint32 IMAllUserReq::latest_update_time() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMAllUserReq.latest_update_time)
  return latest_update_time_;
}
inline void IMAllUserReq::set_latest_update_time(::google::protobuf::uint32 value) {
  set_has_latest_update_time();
  latest_update_time_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMAllUserReq.latest_update_time)
}

// optional bytes attach_data = 20;
inline bool IMAllUserReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMAllUserReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMAllUserReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMAllUserReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMAllUserReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMAllUserReq.attach_data)
  return *attach_data_;
}
inline void IMAllUserReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMAllUserReq.attach_data)
}
inline void IMAllUserReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMAllUserReq.attach_data)
}
inline void IMAllUserReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMAllUserReq.attach_data)
}
inline ::std::string* IMAllUserReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMAllUserReq.attach_data)
  return attach_data_;
}
inline ::std::string* IMAllUserReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMAllUserReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMAllUserReq.attach_data)
}

// -------------------------------------------------------------------

// IMAllUserRsp

// required uint32 user_id = 1;
inline bool IMAllUserRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMAllUserRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMAllUserRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMAllUserRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMAllUserRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMAllUserRsp.user_id)
  return user_id_;
}
inline void IMAllUserRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMAllUserRsp.user_id)
}

// required uint32 latest_update_time = 2;
inline bool IMAllUserRsp::has_latest_update_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMAllUserRsp::set_has_latest_update_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMAllUserRsp::clear_has_latest_update_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMAllUserRsp::clear_latest_update_time() {
  latest_update_time_ = 0u;
  clear_has_latest_update_time();
}
inline ::google::protobuf::uint32 IMAllUserRsp::latest_update_time() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMAllUserRsp.latest_update_time)
  return latest_update_time_;
}
inline void IMAllUserRsp::set_latest_update_time(::google::protobuf::uint32 value) {
  set_has_latest_update_time();
  latest_update_time_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMAllUserRsp.latest_update_time)
}

// repeated .IM.BaseDefine.UserInfo user_list = 3;
inline int IMAllUserRsp::user_list_size() const {
  return user_list_.size();
}
inline void IMAllUserRsp::clear_user_list() {
  user_list_.Clear();
}
inline const ::IM::BaseDefine::UserInfo& IMAllUserRsp::user_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMAllUserRsp.user_list)
  return user_list_.Get(index);
}
inline ::IM::BaseDefine::UserInfo* IMAllUserRsp::mutable_user_list(int index) {
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMAllUserRsp.user_list)
  return user_list_.Mutable(index);
}
inline ::IM::BaseDefine::UserInfo* IMAllUserRsp::add_user_list() {
  // @@protoc_insertion_point(field_add:IM.Buddy.IMAllUserRsp.user_list)
  return user_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserInfo >&
IMAllUserRsp::user_list() const {
  // @@protoc_insertion_point(field_list:IM.Buddy.IMAllUserRsp.user_list)
  return user_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserInfo >*
IMAllUserRsp::mutable_user_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.Buddy.IMAllUserRsp.user_list)
  return &user_list_;
}

// optional bytes attach_data = 20;
inline bool IMAllUserRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMAllUserRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMAllUserRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMAllUserRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMAllUserRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMAllUserRsp.attach_data)
  return *attach_data_;
}
inline void IMAllUserRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMAllUserRsp.attach_data)
}
inline void IMAllUserRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMAllUserRsp.attach_data)
}
inline void IMAllUserRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMAllUserRsp.attach_data)
}
inline ::std::string* IMAllUserRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMAllUserRsp.attach_data)
  return attach_data_;
}
inline ::std::string* IMAllUserRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMAllUserRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMAllUserRsp.attach_data)
}

// -------------------------------------------------------------------

// IMUsersStatReq

// required uint32 user_id = 1;
inline bool IMUsersStatReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMUsersStatReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMUsersStatReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMUsersStatReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMUsersStatReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUsersStatReq.user_id)
  return user_id_;
}
inline void IMUsersStatReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUsersStatReq.user_id)
}

// repeated uint32 user_id_list = 2;
inline int IMUsersStatReq::user_id_list_size() const {
  return user_id_list_.size();
}
inline void IMUsersStatReq::clear_user_id_list() {
  user_id_list_.Clear();
}
inline ::google::protobuf::uint32 IMUsersStatReq::user_id_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUsersStatReq.user_id_list)
  return user_id_list_.Get(index);
}
inline void IMUsersStatReq::set_user_id_list(int index, ::google::protobuf::uint32 value) {
  user_id_list_.Set(index, value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUsersStatReq.user_id_list)
}
inline void IMUsersStatReq::add_user_id_list(::google::protobuf::uint32 value) {
  user_id_list_.Add(value);
  // @@protoc_insertion_point(field_add:IM.Buddy.IMUsersStatReq.user_id_list)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
IMUsersStatReq::user_id_list() const {
  // @@protoc_insertion_point(field_list:IM.Buddy.IMUsersStatReq.user_id_list)
  return user_id_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
IMUsersStatReq::mutable_user_id_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.Buddy.IMUsersStatReq.user_id_list)
  return &user_id_list_;
}

// optional bytes attach_data = 20;
inline bool IMUsersStatReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMUsersStatReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMUsersStatReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMUsersStatReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMUsersStatReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUsersStatReq.attach_data)
  return *attach_data_;
}
inline void IMUsersStatReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUsersStatReq.attach_data)
}
inline void IMUsersStatReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMUsersStatReq.attach_data)
}
inline void IMUsersStatReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMUsersStatReq.attach_data)
}
inline ::std::string* IMUsersStatReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMUsersStatReq.attach_data)
  return attach_data_;
}
inline ::std::string* IMUsersStatReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMUsersStatReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMUsersStatReq.attach_data)
}

// -------------------------------------------------------------------

// IMUsersStatRsp

// required uint32 user_id = 1;
inline bool IMUsersStatRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMUsersStatRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMUsersStatRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMUsersStatRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMUsersStatRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUsersStatRsp.user_id)
  return user_id_;
}
inline void IMUsersStatRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUsersStatRsp.user_id)
}

// repeated .IM.BaseDefine.UserStat user_stat_list = 2;
inline int IMUsersStatRsp::user_stat_list_size() const {
  return user_stat_list_.size();
}
inline void IMUsersStatRsp::clear_user_stat_list() {
  user_stat_list_.Clear();
}
inline const ::IM::BaseDefine::UserStat& IMUsersStatRsp::user_stat_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUsersStatRsp.user_stat_list)
  return user_stat_list_.Get(index);
}
inline ::IM::BaseDefine::UserStat* IMUsersStatRsp::mutable_user_stat_list(int index) {
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMUsersStatRsp.user_stat_list)
  return user_stat_list_.Mutable(index);
}
inline ::IM::BaseDefine::UserStat* IMUsersStatRsp::add_user_stat_list() {
  // @@protoc_insertion_point(field_add:IM.Buddy.IMUsersStatRsp.user_stat_list)
  return user_stat_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserStat >&
IMUsersStatRsp::user_stat_list() const {
  // @@protoc_insertion_point(field_list:IM.Buddy.IMUsersStatRsp.user_stat_list)
  return user_stat_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserStat >*
IMUsersStatRsp::mutable_user_stat_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.Buddy.IMUsersStatRsp.user_stat_list)
  return &user_stat_list_;
}

// optional bytes attach_data = 20;
inline bool IMUsersStatRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMUsersStatRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMUsersStatRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMUsersStatRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMUsersStatRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUsersStatRsp.attach_data)
  return *attach_data_;
}
inline void IMUsersStatRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUsersStatRsp.attach_data)
}
inline void IMUsersStatRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMUsersStatRsp.attach_data)
}
inline void IMUsersStatRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMUsersStatRsp.attach_data)
}
inline ::std::string* IMUsersStatRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMUsersStatRsp.attach_data)
  return attach_data_;
}
inline ::std::string* IMUsersStatRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMUsersStatRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMUsersStatRsp.attach_data)
}

// -------------------------------------------------------------------

// IMChangeAvatarReq

// required uint32 user_id = 1;
inline bool IMChangeAvatarReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMChangeAvatarReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMChangeAvatarReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMChangeAvatarReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMChangeAvatarReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMChangeAvatarReq.user_id)
  return user_id_;
}
inline void IMChangeAvatarReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMChangeAvatarReq.user_id)
}

// required string avatar_url = 2;
inline bool IMChangeAvatarReq::has_avatar_url() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMChangeAvatarReq::set_has_avatar_url() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMChangeAvatarReq::clear_has_avatar_url() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMChangeAvatarReq::clear_avatar_url() {
  if (avatar_url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_url_->clear();
  }
  clear_has_avatar_url();
}
inline const ::std::string& IMChangeAvatarReq::avatar_url() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMChangeAvatarReq.avatar_url)
  return *avatar_url_;
}
inline void IMChangeAvatarReq::set_avatar_url(const ::std::string& value) {
  set_has_avatar_url();
  if (avatar_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_url_ = new ::std::string;
  }
  avatar_url_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMChangeAvatarReq.avatar_url)
}
inline void IMChangeAvatarReq::set_avatar_url(const char* value) {
  set_has_avatar_url();
  if (avatar_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_url_ = new ::std::string;
  }
  avatar_url_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMChangeAvatarReq.avatar_url)
}
inline void IMChangeAvatarReq::set_avatar_url(const char* value, size_t size) {
  set_has_avatar_url();
  if (avatar_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_url_ = new ::std::string;
  }
  avatar_url_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMChangeAvatarReq.avatar_url)
}
inline ::std::string* IMChangeAvatarReq::mutable_avatar_url() {
  set_has_avatar_url();
  if (avatar_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_url_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMChangeAvatarReq.avatar_url)
  return avatar_url_;
}
inline ::std::string* IMChangeAvatarReq::release_avatar_url() {
  clear_has_avatar_url();
  if (avatar_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = avatar_url_;
    avatar_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMChangeAvatarReq::set_allocated_avatar_url(::std::string* avatar_url) {
  if (avatar_url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete avatar_url_;
  }
  if (avatar_url) {
    set_has_avatar_url();
    avatar_url_ = avatar_url;
  } else {
    clear_has_avatar_url();
    avatar_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMChangeAvatarReq.avatar_url)
}

// optional bytes attach_data = 20;
inline bool IMChangeAvatarReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMChangeAvatarReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMChangeAvatarReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMChangeAvatarReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMChangeAvatarReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMChangeAvatarReq.attach_data)
  return *attach_data_;
}
inline void IMChangeAvatarReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMChangeAvatarReq.attach_data)
}
inline void IMChangeAvatarReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMChangeAvatarReq.attach_data)
}
inline void IMChangeAvatarReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMChangeAvatarReq.attach_data)
}
inline ::std::string* IMChangeAvatarReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMChangeAvatarReq.attach_data)
  return attach_data_;
}
inline ::std::string* IMChangeAvatarReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMChangeAvatarReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMChangeAvatarReq.attach_data)
}

// -------------------------------------------------------------------

// IMChangeAvatarRsp

// required uint32 user_id = 1;
inline bool IMChangeAvatarRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMChangeAvatarRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMChangeAvatarRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMChangeAvatarRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMChangeAvatarRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMChangeAvatarRsp.user_id)
  return user_id_;
}
inline void IMChangeAvatarRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMChangeAvatarRsp.user_id)
}

// required uint32 result_code = 2;
inline bool IMChangeAvatarRsp::has_result_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMChangeAvatarRsp::set_has_result_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMChangeAvatarRsp::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMChangeAvatarRsp::clear_result_code() {
  result_code_ = 0u;
  clear_has_result_code();
}
inline ::google::protobuf::uint32 IMChangeAvatarRsp::result_code() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMChangeAvatarRsp.result_code)
  return result_code_;
}
inline void IMChangeAvatarRsp::set_result_code(::google::protobuf::uint32 value) {
  set_has_result_code();
  result_code_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMChangeAvatarRsp.result_code)
}

// optional bytes attach_data = 20;
inline bool IMChangeAvatarRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMChangeAvatarRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMChangeAvatarRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMChangeAvatarRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMChangeAvatarRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMChangeAvatarRsp.attach_data)
  return *attach_data_;
}
inline void IMChangeAvatarRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMChangeAvatarRsp.attach_data)
}
inline void IMChangeAvatarRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMChangeAvatarRsp.attach_data)
}
inline void IMChangeAvatarRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMChangeAvatarRsp.attach_data)
}
inline ::std::string* IMChangeAvatarRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMChangeAvatarRsp.attach_data)
  return attach_data_;
}
inline ::std::string* IMChangeAvatarRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMChangeAvatarRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMChangeAvatarRsp.attach_data)
}

// -------------------------------------------------------------------

// IMPCLoginStatusNotify

// required uint32 user_id = 1;
inline bool IMPCLoginStatusNotify::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMPCLoginStatusNotify::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMPCLoginStatusNotify::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMPCLoginStatusNotify::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMPCLoginStatusNotify::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMPCLoginStatusNotify.user_id)
  return user_id_;
}
inline void IMPCLoginStatusNotify::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMPCLoginStatusNotify.user_id)
}

// required .IM.BaseDefine.UserStatType login_stat = 2;
inline bool IMPCLoginStatusNotify::has_login_stat() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMPCLoginStatusNotify::set_has_login_stat() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMPCLoginStatusNotify::clear_has_login_stat() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMPCLoginStatusNotify::clear_login_stat() {
  login_stat_ = 1;
  clear_has_login_stat();
}
inline ::IM::BaseDefine::UserStatType IMPCLoginStatusNotify::login_stat() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMPCLoginStatusNotify.login_stat)
  return static_cast< ::IM::BaseDefine::UserStatType >(login_stat_);
}
inline void IMPCLoginStatusNotify::set_login_stat(::IM::BaseDefine::UserStatType value) {
  assert(::IM::BaseDefine::UserStatType_IsValid(value));
  set_has_login_stat();
  login_stat_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMPCLoginStatusNotify.login_stat)
}

// -------------------------------------------------------------------

// IMRemoveSessionNotify

// required uint32 user_id = 1;
inline bool IMRemoveSessionNotify::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMRemoveSessionNotify::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMRemoveSessionNotify::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMRemoveSessionNotify::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMRemoveSessionNotify::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRemoveSessionNotify.user_id)
  return user_id_;
}
inline void IMRemoveSessionNotify::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRemoveSessionNotify.user_id)
}

// required .IM.BaseDefine.SessionType session_type = 2;
inline bool IMRemoveSessionNotify::has_session_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMRemoveSessionNotify::set_has_session_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMRemoveSessionNotify::clear_has_session_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMRemoveSessionNotify::clear_session_type() {
  session_type_ = 1;
  clear_has_session_type();
}
inline ::IM::BaseDefine::SessionType IMRemoveSessionNotify::session_type() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRemoveSessionNotify.session_type)
  return static_cast< ::IM::BaseDefine::SessionType >(session_type_);
}
inline void IMRemoveSessionNotify::set_session_type(::IM::BaseDefine::SessionType value) {
  assert(::IM::BaseDefine::SessionType_IsValid(value));
  set_has_session_type();
  session_type_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRemoveSessionNotify.session_type)
}

// required uint32 session_id = 3;
inline bool IMRemoveSessionNotify::has_session_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMRemoveSessionNotify::set_has_session_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMRemoveSessionNotify::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMRemoveSessionNotify::clear_session_id() {
  session_id_ = 0u;
  clear_has_session_id();
}
inline ::google::protobuf::uint32 IMRemoveSessionNotify::session_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRemoveSessionNotify.session_id)
  return session_id_;
}
inline void IMRemoveSessionNotify::set_session_id(::google::protobuf::uint32 value) {
  set_has_session_id();
  session_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRemoveSessionNotify.session_id)
}

// -------------------------------------------------------------------

// IMDepartmentReq

// required uint32 user_id = 1;
inline bool IMDepartmentReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMDepartmentReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMDepartmentReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMDepartmentReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMDepartmentReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMDepartmentReq.user_id)
  return user_id_;
}
inline void IMDepartmentReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMDepartmentReq.user_id)
}

// required uint32 latest_update_time = 2;
inline bool IMDepartmentReq::has_latest_update_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMDepartmentReq::set_has_latest_update_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMDepartmentReq::clear_has_latest_update_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMDepartmentReq::clear_latest_update_time() {
  latest_update_time_ = 0u;
  clear_has_latest_update_time();
}
inline ::google::protobuf::uint32 IMDepartmentReq::latest_update_time() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMDepartmentReq.latest_update_time)
  return latest_update_time_;
}
inline void IMDepartmentReq::set_latest_update_time(::google::protobuf::uint32 value) {
  set_has_latest_update_time();
  latest_update_time_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMDepartmentReq.latest_update_time)
}

// optional bytes attach_data = 20;
inline bool IMDepartmentReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMDepartmentReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMDepartmentReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMDepartmentReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMDepartmentReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMDepartmentReq.attach_data)
  return *attach_data_;
}
inline void IMDepartmentReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMDepartmentReq.attach_data)
}
inline void IMDepartmentReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMDepartmentReq.attach_data)
}
inline void IMDepartmentReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMDepartmentReq.attach_data)
}
inline ::std::string* IMDepartmentReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMDepartmentReq.attach_data)
  return attach_data_;
}
inline ::std::string* IMDepartmentReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMDepartmentReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMDepartmentReq.attach_data)
}

// -------------------------------------------------------------------

// IMDepartmentRsp

// required uint32 user_id = 1;
inline bool IMDepartmentRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMDepartmentRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMDepartmentRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMDepartmentRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMDepartmentRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMDepartmentRsp.user_id)
  return user_id_;
}
inline void IMDepartmentRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMDepartmentRsp.user_id)
}

// required uint32 latest_update_time = 2;
inline bool IMDepartmentRsp::has_latest_update_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMDepartmentRsp::set_has_latest_update_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMDepartmentRsp::clear_has_latest_update_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMDepartmentRsp::clear_latest_update_time() {
  latest_update_time_ = 0u;
  clear_has_latest_update_time();
}
inline ::google::protobuf::uint32 IMDepartmentRsp::latest_update_time() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMDepartmentRsp.latest_update_time)
  return latest_update_time_;
}
inline void IMDepartmentRsp::set_latest_update_time(::google::protobuf::uint32 value) {
  set_has_latest_update_time();
  latest_update_time_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMDepartmentRsp.latest_update_time)
}

// repeated .IM.BaseDefine.DepartInfo dept_list = 3;
inline int IMDepartmentRsp::dept_list_size() const {
  return dept_list_.size();
}
inline void IMDepartmentRsp::clear_dept_list() {
  dept_list_.Clear();
}
inline const ::IM::BaseDefine::DepartInfo& IMDepartmentRsp::dept_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMDepartmentRsp.dept_list)
  return dept_list_.Get(index);
}
inline ::IM::BaseDefine::DepartInfo* IMDepartmentRsp::mutable_dept_list(int index) {
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMDepartmentRsp.dept_list)
  return dept_list_.Mutable(index);
}
inline ::IM::BaseDefine::DepartInfo* IMDepartmentRsp::add_dept_list() {
  // @@protoc_insertion_point(field_add:IM.Buddy.IMDepartmentRsp.dept_list)
  return dept_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::DepartInfo >&
IMDepartmentRsp::dept_list() const {
  // @@protoc_insertion_point(field_list:IM.Buddy.IMDepartmentRsp.dept_list)
  return dept_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::DepartInfo >*
IMDepartmentRsp::mutable_dept_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.Buddy.IMDepartmentRsp.dept_list)
  return &dept_list_;
}

// optional bytes attach_data = 20;
inline bool IMDepartmentRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMDepartmentRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMDepartmentRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMDepartmentRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMDepartmentRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMDepartmentRsp.attach_data)
  return *attach_data_;
}
inline void IMDepartmentRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMDepartmentRsp.attach_data)
}
inline void IMDepartmentRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMDepartmentRsp.attach_data)
}
inline void IMDepartmentRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMDepartmentRsp.attach_data)
}
inline ::std::string* IMDepartmentRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMDepartmentRsp.attach_data)
  return attach_data_;
}
inline ::std::string* IMDepartmentRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMDepartmentRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMDepartmentRsp.attach_data)
}

// -------------------------------------------------------------------

// IMAvatarChangedNotify

// required uint32 changed_user_id = 1;
inline bool IMAvatarChangedNotify::has_changed_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMAvatarChangedNotify::set_has_changed_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMAvatarChangedNotify::clear_has_changed_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMAvatarChangedNotify::clear_changed_user_id() {
  changed_user_id_ = 0u;
  clear_has_changed_user_id();
}
inline ::google::protobuf::uint32 IMAvatarChangedNotify::changed_user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMAvatarChangedNotify.changed_user_id)
  return changed_user_id_;
}
inline void IMAvatarChangedNotify::set_changed_user_id(::google::protobuf::uint32 value) {
  set_has_changed_user_id();
  changed_user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMAvatarChangedNotify.changed_user_id)
}

// required string avatar_url = 2;
inline bool IMAvatarChangedNotify::has_avatar_url() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMAvatarChangedNotify::set_has_avatar_url() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMAvatarChangedNotify::clear_has_avatar_url() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMAvatarChangedNotify::clear_avatar_url() {
  if (avatar_url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_url_->clear();
  }
  clear_has_avatar_url();
}
inline const ::std::string& IMAvatarChangedNotify::avatar_url() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMAvatarChangedNotify.avatar_url)
  return *avatar_url_;
}
inline void IMAvatarChangedNotify::set_avatar_url(const ::std::string& value) {
  set_has_avatar_url();
  if (avatar_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_url_ = new ::std::string;
  }
  avatar_url_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMAvatarChangedNotify.avatar_url)
}
inline void IMAvatarChangedNotify::set_avatar_url(const char* value) {
  set_has_avatar_url();
  if (avatar_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_url_ = new ::std::string;
  }
  avatar_url_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMAvatarChangedNotify.avatar_url)
}
inline void IMAvatarChangedNotify::set_avatar_url(const char* value, size_t size) {
  set_has_avatar_url();
  if (avatar_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_url_ = new ::std::string;
  }
  avatar_url_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMAvatarChangedNotify.avatar_url)
}
inline ::std::string* IMAvatarChangedNotify::mutable_avatar_url() {
  set_has_avatar_url();
  if (avatar_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_url_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMAvatarChangedNotify.avatar_url)
  return avatar_url_;
}
inline ::std::string* IMAvatarChangedNotify::release_avatar_url() {
  clear_has_avatar_url();
  if (avatar_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = avatar_url_;
    avatar_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMAvatarChangedNotify::set_allocated_avatar_url(::std::string* avatar_url) {
  if (avatar_url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete avatar_url_;
  }
  if (avatar_url) {
    set_has_avatar_url();
    avatar_url_ = avatar_url;
  } else {
    clear_has_avatar_url();
    avatar_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMAvatarChangedNotify.avatar_url)
}

// -------------------------------------------------------------------

// IMChangeSignInfoReq

// required uint32 user_id = 1;
inline bool IMChangeSignInfoReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMChangeSignInfoReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMChangeSignInfoReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMChangeSignInfoReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMChangeSignInfoReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMChangeSignInfoReq.user_id)
  return user_id_;
}
inline void IMChangeSignInfoReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMChangeSignInfoReq.user_id)
}

// required string sign_info = 2;
inline bool IMChangeSignInfoReq::has_sign_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMChangeSignInfoReq::set_has_sign_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMChangeSignInfoReq::clear_has_sign_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMChangeSignInfoReq::clear_sign_info() {
  if (sign_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_->clear();
  }
  clear_has_sign_info();
}
inline const ::std::string& IMChangeSignInfoReq::sign_info() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMChangeSignInfoReq.sign_info)
  return *sign_info_;
}
inline void IMChangeSignInfoReq::set_sign_info(const ::std::string& value) {
  set_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_ = new ::std::string;
  }
  sign_info_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMChangeSignInfoReq.sign_info)
}
inline void IMChangeSignInfoReq::set_sign_info(const char* value) {
  set_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_ = new ::std::string;
  }
  sign_info_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMChangeSignInfoReq.sign_info)
}
inline void IMChangeSignInfoReq::set_sign_info(const char* value, size_t size) {
  set_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_ = new ::std::string;
  }
  sign_info_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMChangeSignInfoReq.sign_info)
}
inline ::std::string* IMChangeSignInfoReq::mutable_sign_info() {
  set_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMChangeSignInfoReq.sign_info)
  return sign_info_;
}
inline ::std::string* IMChangeSignInfoReq::release_sign_info() {
  clear_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sign_info_;
    sign_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMChangeSignInfoReq::set_allocated_sign_info(::std::string* sign_info) {
  if (sign_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sign_info_;
  }
  if (sign_info) {
    set_has_sign_info();
    sign_info_ = sign_info;
  } else {
    clear_has_sign_info();
    sign_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMChangeSignInfoReq.sign_info)
}

// optional bytes attach_data = 20;
inline bool IMChangeSignInfoReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMChangeSignInfoReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMChangeSignInfoReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMChangeSignInfoReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMChangeSignInfoReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMChangeSignInfoReq.attach_data)
  return *attach_data_;
}
inline void IMChangeSignInfoReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMChangeSignInfoReq.attach_data)
}
inline void IMChangeSignInfoReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMChangeSignInfoReq.attach_data)
}
inline void IMChangeSignInfoReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMChangeSignInfoReq.attach_data)
}
inline ::std::string* IMChangeSignInfoReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMChangeSignInfoReq.attach_data)
  return attach_data_;
}
inline ::std::string* IMChangeSignInfoReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMChangeSignInfoReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMChangeSignInfoReq.attach_data)
}

// -------------------------------------------------------------------

// IMChangeSignInfoRsp

// required uint32 user_id = 1;
inline bool IMChangeSignInfoRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMChangeSignInfoRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMChangeSignInfoRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMChangeSignInfoRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMChangeSignInfoRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMChangeSignInfoRsp.user_id)
  return user_id_;
}
inline void IMChangeSignInfoRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMChangeSignInfoRsp.user_id)
}

// required uint32 result_code = 2;
inline bool IMChangeSignInfoRsp::has_result_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMChangeSignInfoRsp::set_has_result_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMChangeSignInfoRsp::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMChangeSignInfoRsp::clear_result_code() {
  result_code_ = 0u;
  clear_has_result_code();
}
inline ::google::protobuf::uint32 IMChangeSignInfoRsp::result_code() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMChangeSignInfoRsp.result_code)
  return result_code_;
}
inline void IMChangeSignInfoRsp::set_result_code(::google::protobuf::uint32 value) {
  set_has_result_code();
  result_code_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMChangeSignInfoRsp.result_code)
}

// optional string sign_info = 3;
inline bool IMChangeSignInfoRsp::has_sign_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMChangeSignInfoRsp::set_has_sign_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMChangeSignInfoRsp::clear_has_sign_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMChangeSignInfoRsp::clear_sign_info() {
  if (sign_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_->clear();
  }
  clear_has_sign_info();
}
inline const ::std::string& IMChangeSignInfoRsp::sign_info() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMChangeSignInfoRsp.sign_info)
  return *sign_info_;
}
inline void IMChangeSignInfoRsp::set_sign_info(const ::std::string& value) {
  set_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_ = new ::std::string;
  }
  sign_info_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMChangeSignInfoRsp.sign_info)
}
inline void IMChangeSignInfoRsp::set_sign_info(const char* value) {
  set_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_ = new ::std::string;
  }
  sign_info_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMChangeSignInfoRsp.sign_info)
}
inline void IMChangeSignInfoRsp::set_sign_info(const char* value, size_t size) {
  set_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_ = new ::std::string;
  }
  sign_info_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMChangeSignInfoRsp.sign_info)
}
inline ::std::string* IMChangeSignInfoRsp::mutable_sign_info() {
  set_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMChangeSignInfoRsp.sign_info)
  return sign_info_;
}
inline ::std::string* IMChangeSignInfoRsp::release_sign_info() {
  clear_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sign_info_;
    sign_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMChangeSignInfoRsp::set_allocated_sign_info(::std::string* sign_info) {
  if (sign_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sign_info_;
  }
  if (sign_info) {
    set_has_sign_info();
    sign_info_ = sign_info;
  } else {
    clear_has_sign_info();
    sign_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMChangeSignInfoRsp.sign_info)
}

// optional bytes attach_data = 20;
inline bool IMChangeSignInfoRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMChangeSignInfoRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMChangeSignInfoRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMChangeSignInfoRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMChangeSignInfoRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMChangeSignInfoRsp.attach_data)
  return *attach_data_;
}
inline void IMChangeSignInfoRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMChangeSignInfoRsp.attach_data)
}
inline void IMChangeSignInfoRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMChangeSignInfoRsp.attach_data)
}
inline void IMChangeSignInfoRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMChangeSignInfoRsp.attach_data)
}
inline ::std::string* IMChangeSignInfoRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMChangeSignInfoRsp.attach_data)
  return attach_data_;
}
inline ::std::string* IMChangeSignInfoRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMChangeSignInfoRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMChangeSignInfoRsp.attach_data)
}

// -------------------------------------------------------------------

// IMSignInfoChangedNotify

// required uint32 changed_user_id = 1;
inline bool IMSignInfoChangedNotify::has_changed_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMSignInfoChangedNotify::set_has_changed_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMSignInfoChangedNotify::clear_has_changed_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMSignInfoChangedNotify::clear_changed_user_id() {
  changed_user_id_ = 0u;
  clear_has_changed_user_id();
}
inline ::google::protobuf::uint32 IMSignInfoChangedNotify::changed_user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMSignInfoChangedNotify.changed_user_id)
  return changed_user_id_;
}
inline void IMSignInfoChangedNotify::set_changed_user_id(::google::protobuf::uint32 value) {
  set_has_changed_user_id();
  changed_user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMSignInfoChangedNotify.changed_user_id)
}

// required string sign_info = 2;
inline bool IMSignInfoChangedNotify::has_sign_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMSignInfoChangedNotify::set_has_sign_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMSignInfoChangedNotify::clear_has_sign_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMSignInfoChangedNotify::clear_sign_info() {
  if (sign_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_->clear();
  }
  clear_has_sign_info();
}
inline const ::std::string& IMSignInfoChangedNotify::sign_info() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMSignInfoChangedNotify.sign_info)
  return *sign_info_;
}
inline void IMSignInfoChangedNotify::set_sign_info(const ::std::string& value) {
  set_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_ = new ::std::string;
  }
  sign_info_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMSignInfoChangedNotify.sign_info)
}
inline void IMSignInfoChangedNotify::set_sign_info(const char* value) {
  set_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_ = new ::std::string;
  }
  sign_info_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMSignInfoChangedNotify.sign_info)
}
inline void IMSignInfoChangedNotify::set_sign_info(const char* value, size_t size) {
  set_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_ = new ::std::string;
  }
  sign_info_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMSignInfoChangedNotify.sign_info)
}
inline ::std::string* IMSignInfoChangedNotify::mutable_sign_info() {
  set_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMSignInfoChangedNotify.sign_info)
  return sign_info_;
}
inline ::std::string* IMSignInfoChangedNotify::release_sign_info() {
  clear_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sign_info_;
    sign_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMSignInfoChangedNotify::set_allocated_sign_info(::std::string* sign_info) {
  if (sign_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sign_info_;
  }
  if (sign_info) {
    set_has_sign_info();
    sign_info_ = sign_info;
  } else {
    clear_has_sign_info();
    sign_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMSignInfoChangedNotify.sign_info)
}

// -------------------------------------------------------------------

// TravelRouteReq

// required uint32 user_id = 1;
inline bool TravelRouteReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TravelRouteReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TravelRouteReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TravelRouteReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 TravelRouteReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.TravelRouteReq.user_id)
  return user_id_;
}
inline void TravelRouteReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.TravelRouteReq.user_id)
}

// required uint32 travel_type = 2;
inline bool TravelRouteReq::has_travel_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TravelRouteReq::set_has_travel_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TravelRouteReq::clear_has_travel_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TravelRouteReq::clear_travel_type() {
  travel_type_ = 0u;
  clear_has_travel_type();
}
inline ::google::protobuf::uint32 TravelRouteReq::travel_type() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.TravelRouteReq.travel_type)
  return travel_type_;
}
inline void TravelRouteReq::set_travel_type(::google::protobuf::uint32 value) {
  set_has_travel_type();
  travel_type_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.TravelRouteReq.travel_type)
}

// required string lines = 3;
inline bool TravelRouteReq::has_lines() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TravelRouteReq::set_has_lines() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TravelRouteReq::clear_has_lines() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TravelRouteReq::clear_lines() {
  if (lines_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lines_->clear();
  }
  clear_has_lines();
}
inline const ::std::string& TravelRouteReq::lines() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.TravelRouteReq.lines)
  return *lines_;
}
inline void TravelRouteReq::set_lines(const ::std::string& value) {
  set_has_lines();
  if (lines_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lines_ = new ::std::string;
  }
  lines_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.TravelRouteReq.lines)
}
inline void TravelRouteReq::set_lines(const char* value) {
  set_has_lines();
  if (lines_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lines_ = new ::std::string;
  }
  lines_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.TravelRouteReq.lines)
}
inline void TravelRouteReq::set_lines(const char* value, size_t size) {
  set_has_lines();
  if (lines_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lines_ = new ::std::string;
  }
  lines_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.TravelRouteReq.lines)
}
inline ::std::string* TravelRouteReq::mutable_lines() {
  set_has_lines();
  if (lines_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lines_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.TravelRouteReq.lines)
  return lines_;
}
inline ::std::string* TravelRouteReq::release_lines() {
  clear_has_lines();
  if (lines_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = lines_;
    lines_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TravelRouteReq::set_allocated_lines(::std::string* lines) {
  if (lines_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete lines_;
  }
  if (lines) {
    set_has_lines();
    lines_ = lines;
  } else {
    clear_has_lines();
    lines_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.TravelRouteReq.lines)
}

// required uint32 time_from = 4;
inline bool TravelRouteReq::has_time_from() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TravelRouteReq::set_has_time_from() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TravelRouteReq::clear_has_time_from() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TravelRouteReq::clear_time_from() {
  time_from_ = 0u;
  clear_has_time_from();
}
inline ::google::protobuf::uint32 TravelRouteReq::time_from() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.TravelRouteReq.time_from)
  return time_from_;
}
inline void TravelRouteReq::set_time_from(::google::protobuf::uint32 value) {
  set_has_time_from();
  time_from_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.TravelRouteReq.time_from)
}

// required uint32 time_to = 5;
inline bool TravelRouteReq::has_time_to() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TravelRouteReq::set_has_time_to() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TravelRouteReq::clear_has_time_to() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TravelRouteReq::clear_time_to() {
  time_to_ = 0u;
  clear_has_time_to();
}
inline ::google::protobuf::uint32 TravelRouteReq::time_to() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.TravelRouteReq.time_to)
  return time_to_;
}
inline void TravelRouteReq::set_time_to(::google::protobuf::uint32 value) {
  set_has_time_to();
  time_to_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.TravelRouteReq.time_to)
}

// optional bytes attach_data = 20;
inline bool TravelRouteReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TravelRouteReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TravelRouteReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TravelRouteReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& TravelRouteReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.TravelRouteReq.attach_data)
  return *attach_data_;
}
inline void TravelRouteReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.TravelRouteReq.attach_data)
}
inline void TravelRouteReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.TravelRouteReq.attach_data)
}
inline void TravelRouteReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.TravelRouteReq.attach_data)
}
inline ::std::string* TravelRouteReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.TravelRouteReq.attach_data)
  return attach_data_;
}
inline ::std::string* TravelRouteReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TravelRouteReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.TravelRouteReq.attach_data)
}

// -------------------------------------------------------------------

// TravelToolInfo

// required uint32 travel_type = 1;
inline bool TravelToolInfo::has_travel_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TravelToolInfo::set_has_travel_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TravelToolInfo::clear_has_travel_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TravelToolInfo::clear_travel_type() {
  travel_type_ = 0u;
  clear_has_travel_type();
}
inline ::google::protobuf::uint32 TravelToolInfo::travel_type() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.TravelToolInfo.travel_type)
  return travel_type_;
}
inline void TravelToolInfo::set_travel_type(::google::protobuf::uint32 value) {
  set_has_travel_type();
  travel_type_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.TravelToolInfo.travel_type)
}

// required string no = 2;
inline bool TravelToolInfo::has_no() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TravelToolInfo::set_has_no() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TravelToolInfo::clear_has_no() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TravelToolInfo::clear_no() {
  if (no_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    no_->clear();
  }
  clear_has_no();
}
inline const ::std::string& TravelToolInfo::no() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.TravelToolInfo.no)
  return *no_;
}
inline void TravelToolInfo::set_no(const ::std::string& value) {
  set_has_no();
  if (no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    no_ = new ::std::string;
  }
  no_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.TravelToolInfo.no)
}
inline void TravelToolInfo::set_no(const char* value) {
  set_has_no();
  if (no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    no_ = new ::std::string;
  }
  no_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.TravelToolInfo.no)
}
inline void TravelToolInfo::set_no(const char* value, size_t size) {
  set_has_no();
  if (no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    no_ = new ::std::string;
  }
  no_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.TravelToolInfo.no)
}
inline ::std::string* TravelToolInfo::mutable_no() {
  set_has_no();
  if (no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    no_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.TravelToolInfo.no)
  return no_;
}
inline ::std::string* TravelToolInfo::release_no() {
  clear_has_no();
  if (no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = no_;
    no_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TravelToolInfo::set_allocated_no(::std::string* no) {
  if (no_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete no_;
  }
  if (no) {
    set_has_no();
    no_ = no;
  } else {
    clear_has_no();
    no_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.TravelToolInfo.no)
}

// required string place_from_code = 3;
inline bool TravelToolInfo::has_place_from_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TravelToolInfo::set_has_place_from_code() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TravelToolInfo::clear_has_place_from_code() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TravelToolInfo::clear_place_from_code() {
  if (place_from_code_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_from_code_->clear();
  }
  clear_has_place_from_code();
}
inline const ::std::string& TravelToolInfo::place_from_code() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.TravelToolInfo.place_from_code)
  return *place_from_code_;
}
inline void TravelToolInfo::set_place_from_code(const ::std::string& value) {
  set_has_place_from_code();
  if (place_from_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_from_code_ = new ::std::string;
  }
  place_from_code_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.TravelToolInfo.place_from_code)
}
inline void TravelToolInfo::set_place_from_code(const char* value) {
  set_has_place_from_code();
  if (place_from_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_from_code_ = new ::std::string;
  }
  place_from_code_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.TravelToolInfo.place_from_code)
}
inline void TravelToolInfo::set_place_from_code(const char* value, size_t size) {
  set_has_place_from_code();
  if (place_from_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_from_code_ = new ::std::string;
  }
  place_from_code_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.TravelToolInfo.place_from_code)
}
inline ::std::string* TravelToolInfo::mutable_place_from_code() {
  set_has_place_from_code();
  if (place_from_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_from_code_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.TravelToolInfo.place_from_code)
  return place_from_code_;
}
inline ::std::string* TravelToolInfo::release_place_from_code() {
  clear_has_place_from_code();
  if (place_from_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = place_from_code_;
    place_from_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TravelToolInfo::set_allocated_place_from_code(::std::string* place_from_code) {
  if (place_from_code_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete place_from_code_;
  }
  if (place_from_code) {
    set_has_place_from_code();
    place_from_code_ = place_from_code;
  } else {
    clear_has_place_from_code();
    place_from_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.TravelToolInfo.place_from_code)
}

// required string place_from = 4;
inline bool TravelToolInfo::has_place_from() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TravelToolInfo::set_has_place_from() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TravelToolInfo::clear_has_place_from() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TravelToolInfo::clear_place_from() {
  if (place_from_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_from_->clear();
  }
  clear_has_place_from();
}
inline const ::std::string& TravelToolInfo::place_from() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.TravelToolInfo.place_from)
  return *place_from_;
}
inline void TravelToolInfo::set_place_from(const ::std::string& value) {
  set_has_place_from();
  if (place_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_from_ = new ::std::string;
  }
  place_from_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.TravelToolInfo.place_from)
}
inline void TravelToolInfo::set_place_from(const char* value) {
  set_has_place_from();
  if (place_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_from_ = new ::std::string;
  }
  place_from_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.TravelToolInfo.place_from)
}
inline void TravelToolInfo::set_place_from(const char* value, size_t size) {
  set_has_place_from();
  if (place_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_from_ = new ::std::string;
  }
  place_from_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.TravelToolInfo.place_from)
}
inline ::std::string* TravelToolInfo::mutable_place_from() {
  set_has_place_from();
  if (place_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_from_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.TravelToolInfo.place_from)
  return place_from_;
}
inline ::std::string* TravelToolInfo::release_place_from() {
  clear_has_place_from();
  if (place_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = place_from_;
    place_from_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TravelToolInfo::set_allocated_place_from(::std::string* place_from) {
  if (place_from_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete place_from_;
  }
  if (place_from) {
    set_has_place_from();
    place_from_ = place_from;
  } else {
    clear_has_place_from();
    place_from_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.TravelToolInfo.place_from)
}

// required string place_to_code = 5;
inline bool TravelToolInfo::has_place_to_code() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TravelToolInfo::set_has_place_to_code() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TravelToolInfo::clear_has_place_to_code() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TravelToolInfo::clear_place_to_code() {
  if (place_to_code_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_to_code_->clear();
  }
  clear_has_place_to_code();
}
inline const ::std::string& TravelToolInfo::place_to_code() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.TravelToolInfo.place_to_code)
  return *place_to_code_;
}
inline void TravelToolInfo::set_place_to_code(const ::std::string& value) {
  set_has_place_to_code();
  if (place_to_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_to_code_ = new ::std::string;
  }
  place_to_code_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.TravelToolInfo.place_to_code)
}
inline void TravelToolInfo::set_place_to_code(const char* value) {
  set_has_place_to_code();
  if (place_to_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_to_code_ = new ::std::string;
  }
  place_to_code_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.TravelToolInfo.place_to_code)
}
inline void TravelToolInfo::set_place_to_code(const char* value, size_t size) {
  set_has_place_to_code();
  if (place_to_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_to_code_ = new ::std::string;
  }
  place_to_code_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.TravelToolInfo.place_to_code)
}
inline ::std::string* TravelToolInfo::mutable_place_to_code() {
  set_has_place_to_code();
  if (place_to_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_to_code_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.TravelToolInfo.place_to_code)
  return place_to_code_;
}
inline ::std::string* TravelToolInfo::release_place_to_code() {
  clear_has_place_to_code();
  if (place_to_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = place_to_code_;
    place_to_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TravelToolInfo::set_allocated_place_to_code(::std::string* place_to_code) {
  if (place_to_code_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete place_to_code_;
  }
  if (place_to_code) {
    set_has_place_to_code();
    place_to_code_ = place_to_code;
  } else {
    clear_has_place_to_code();
    place_to_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.TravelToolInfo.place_to_code)
}

// required string place_to = 6;
inline bool TravelToolInfo::has_place_to() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TravelToolInfo::set_has_place_to() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TravelToolInfo::clear_has_place_to() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TravelToolInfo::clear_place_to() {
  if (place_to_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_to_->clear();
  }
  clear_has_place_to();
}
inline const ::std::string& TravelToolInfo::place_to() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.TravelToolInfo.place_to)
  return *place_to_;
}
inline void TravelToolInfo::set_place_to(const ::std::string& value) {
  set_has_place_to();
  if (place_to_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_to_ = new ::std::string;
  }
  place_to_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.TravelToolInfo.place_to)
}
inline void TravelToolInfo::set_place_to(const char* value) {
  set_has_place_to();
  if (place_to_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_to_ = new ::std::string;
  }
  place_to_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.TravelToolInfo.place_to)
}
inline void TravelToolInfo::set_place_to(const char* value, size_t size) {
  set_has_place_to();
  if (place_to_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_to_ = new ::std::string;
  }
  place_to_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.TravelToolInfo.place_to)
}
inline ::std::string* TravelToolInfo::mutable_place_to() {
  set_has_place_to();
  if (place_to_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_to_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.TravelToolInfo.place_to)
  return place_to_;
}
inline ::std::string* TravelToolInfo::release_place_to() {
  clear_has_place_to();
  if (place_to_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = place_to_;
    place_to_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TravelToolInfo::set_allocated_place_to(::std::string* place_to) {
  if (place_to_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete place_to_;
  }
  if (place_to) {
    set_has_place_to();
    place_to_ = place_to;
  } else {
    clear_has_place_to();
    place_to_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.TravelToolInfo.place_to)
}

// required string time_from = 7;
inline bool TravelToolInfo::has_time_from() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TravelToolInfo::set_has_time_from() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TravelToolInfo::clear_has_time_from() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TravelToolInfo::clear_time_from() {
  if (time_from_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_from_->clear();
  }
  clear_has_time_from();
}
inline const ::std::string& TravelToolInfo::time_from() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.TravelToolInfo.time_from)
  return *time_from_;
}
inline void TravelToolInfo::set_time_from(const ::std::string& value) {
  set_has_time_from();
  if (time_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_from_ = new ::std::string;
  }
  time_from_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.TravelToolInfo.time_from)
}
inline void TravelToolInfo::set_time_from(const char* value) {
  set_has_time_from();
  if (time_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_from_ = new ::std::string;
  }
  time_from_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.TravelToolInfo.time_from)
}
inline void TravelToolInfo::set_time_from(const char* value, size_t size) {
  set_has_time_from();
  if (time_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_from_ = new ::std::string;
  }
  time_from_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.TravelToolInfo.time_from)
}
inline ::std::string* TravelToolInfo::mutable_time_from() {
  set_has_time_from();
  if (time_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_from_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.TravelToolInfo.time_from)
  return time_from_;
}
inline ::std::string* TravelToolInfo::release_time_from() {
  clear_has_time_from();
  if (time_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = time_from_;
    time_from_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TravelToolInfo::set_allocated_time_from(::std::string* time_from) {
  if (time_from_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete time_from_;
  }
  if (time_from) {
    set_has_time_from();
    time_from_ = time_from;
  } else {
    clear_has_time_from();
    time_from_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.TravelToolInfo.time_from)
}

// required string time_to = 8;
inline bool TravelToolInfo::has_time_to() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TravelToolInfo::set_has_time_to() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TravelToolInfo::clear_has_time_to() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TravelToolInfo::clear_time_to() {
  if (time_to_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_to_->clear();
  }
  clear_has_time_to();
}
inline const ::std::string& TravelToolInfo::time_to() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.TravelToolInfo.time_to)
  return *time_to_;
}
inline void TravelToolInfo::set_time_to(const ::std::string& value) {
  set_has_time_to();
  if (time_to_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_to_ = new ::std::string;
  }
  time_to_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.TravelToolInfo.time_to)
}
inline void TravelToolInfo::set_time_to(const char* value) {
  set_has_time_to();
  if (time_to_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_to_ = new ::std::string;
  }
  time_to_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.TravelToolInfo.time_to)
}
inline void TravelToolInfo::set_time_to(const char* value, size_t size) {
  set_has_time_to();
  if (time_to_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_to_ = new ::std::string;
  }
  time_to_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.TravelToolInfo.time_to)
}
inline ::std::string* TravelToolInfo::mutable_time_to() {
  set_has_time_to();
  if (time_to_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_to_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.TravelToolInfo.time_to)
  return time_to_;
}
inline ::std::string* TravelToolInfo::release_time_to() {
  clear_has_time_to();
  if (time_to_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = time_to_;
    time_to_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TravelToolInfo::set_allocated_time_to(::std::string* time_to) {
  if (time_to_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete time_to_;
  }
  if (time_to) {
    set_has_time_to();
    time_to_ = time_to;
  } else {
    clear_has_time_to();
    time_to_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.TravelToolInfo.time_to)
}

// required uint32 price = 9;
inline bool TravelToolInfo::has_price() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TravelToolInfo::set_has_price() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TravelToolInfo::clear_has_price() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TravelToolInfo::clear_price() {
  price_ = 0u;
  clear_has_price();
}
inline ::google::protobuf::uint32 TravelToolInfo::price() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.TravelToolInfo.price)
  return price_;
}
inline void TravelToolInfo::set_price(::google::protobuf::uint32 value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.TravelToolInfo.price)
}

// -------------------------------------------------------------------

// TravelRouteRsp

// required uint32 user_id = 1;
inline bool TravelRouteRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TravelRouteRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TravelRouteRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TravelRouteRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 TravelRouteRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.TravelRouteRsp.user_id)
  return user_id_;
}
inline void TravelRouteRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.TravelRouteRsp.user_id)
}

// required uint32 result_code = 2;
inline bool TravelRouteRsp::has_result_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TravelRouteRsp::set_has_result_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TravelRouteRsp::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TravelRouteRsp::clear_result_code() {
  result_code_ = 0u;
  clear_has_result_code();
}
inline ::google::protobuf::uint32 TravelRouteRsp::result_code() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.TravelRouteRsp.result_code)
  return result_code_;
}
inline void TravelRouteRsp::set_result_code(::google::protobuf::uint32 value) {
  set_has_result_code();
  result_code_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.TravelRouteRsp.result_code)
}

// repeated .IM.Buddy.TravelToolInfo travel_tool_info = 3;
inline int TravelRouteRsp::travel_tool_info_size() const {
  return travel_tool_info_.size();
}
inline void TravelRouteRsp::clear_travel_tool_info() {
  travel_tool_info_.Clear();
}
inline const ::IM::Buddy::TravelToolInfo& TravelRouteRsp::travel_tool_info(int index) const {
  // @@protoc_insertion_point(field_get:IM.Buddy.TravelRouteRsp.travel_tool_info)
  return travel_tool_info_.Get(index);
}
inline ::IM::Buddy::TravelToolInfo* TravelRouteRsp::mutable_travel_tool_info(int index) {
  // @@protoc_insertion_point(field_mutable:IM.Buddy.TravelRouteRsp.travel_tool_info)
  return travel_tool_info_.Mutable(index);
}
inline ::IM::Buddy::TravelToolInfo* TravelRouteRsp::add_travel_tool_info() {
  // @@protoc_insertion_point(field_add:IM.Buddy.TravelRouteRsp.travel_tool_info)
  return travel_tool_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::Buddy::TravelToolInfo >&
TravelRouteRsp::travel_tool_info() const {
  // @@protoc_insertion_point(field_list:IM.Buddy.TravelRouteRsp.travel_tool_info)
  return travel_tool_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::Buddy::TravelToolInfo >*
TravelRouteRsp::mutable_travel_tool_info() {
  // @@protoc_insertion_point(field_mutable_list:IM.Buddy.TravelRouteRsp.travel_tool_info)
  return &travel_tool_info_;
}

// -------------------------------------------------------------------

// TravelInfo

// required uint32 person_num = 1;
inline bool TravelInfo::has_person_num() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TravelInfo::set_has_person_num() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TravelInfo::clear_has_person_num() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TravelInfo::clear_person_num() {
  person_num_ = 0u;
  clear_has_person_num();
}
inline ::google::protobuf::uint32 TravelInfo::person_num() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.TravelInfo.person_num)
  return person_num_;
}
inline void TravelInfo::set_person_num(::google::protobuf::uint32 value) {
  set_has_person_num();
  person_num_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.TravelInfo.person_num)
}

// required string place_from = 2;
inline bool TravelInfo::has_place_from() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TravelInfo::set_has_place_from() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TravelInfo::clear_has_place_from() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TravelInfo::clear_place_from() {
  if (place_from_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_from_->clear();
  }
  clear_has_place_from();
}
inline const ::std::string& TravelInfo::place_from() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.TravelInfo.place_from)
  return *place_from_;
}
inline void TravelInfo::set_place_from(const ::std::string& value) {
  set_has_place_from();
  if (place_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_from_ = new ::std::string;
  }
  place_from_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.TravelInfo.place_from)
}
inline void TravelInfo::set_place_from(const char* value) {
  set_has_place_from();
  if (place_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_from_ = new ::std::string;
  }
  place_from_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.TravelInfo.place_from)
}
inline void TravelInfo::set_place_from(const char* value, size_t size) {
  set_has_place_from();
  if (place_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_from_ = new ::std::string;
  }
  place_from_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.TravelInfo.place_from)
}
inline ::std::string* TravelInfo::mutable_place_from() {
  set_has_place_from();
  if (place_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_from_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.TravelInfo.place_from)
  return place_from_;
}
inline ::std::string* TravelInfo::release_place_from() {
  clear_has_place_from();
  if (place_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = place_from_;
    place_from_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TravelInfo::set_allocated_place_from(::std::string* place_from) {
  if (place_from_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete place_from_;
  }
  if (place_from) {
    set_has_place_from();
    place_from_ = place_from;
  } else {
    clear_has_place_from();
    place_from_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.TravelInfo.place_from)
}

// required string place_back = 3;
inline bool TravelInfo::has_place_back() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TravelInfo::set_has_place_back() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TravelInfo::clear_has_place_back() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TravelInfo::clear_place_back() {
  if (place_back_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_back_->clear();
  }
  clear_has_place_back();
}
inline const ::std::string& TravelInfo::place_back() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.TravelInfo.place_back)
  return *place_back_;
}
inline void TravelInfo::set_place_back(const ::std::string& value) {
  set_has_place_back();
  if (place_back_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_back_ = new ::std::string;
  }
  place_back_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.TravelInfo.place_back)
}
inline void TravelInfo::set_place_back(const char* value) {
  set_has_place_back();
  if (place_back_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_back_ = new ::std::string;
  }
  place_back_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.TravelInfo.place_back)
}
inline void TravelInfo::set_place_back(const char* value, size_t size) {
  set_has_place_back();
  if (place_back_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_back_ = new ::std::string;
  }
  place_back_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.TravelInfo.place_back)
}
inline ::std::string* TravelInfo::mutable_place_back() {
  set_has_place_back();
  if (place_back_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_back_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.TravelInfo.place_back)
  return place_back_;
}
inline ::std::string* TravelInfo::release_place_back() {
  clear_has_place_back();
  if (place_back_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = place_back_;
    place_back_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TravelInfo::set_allocated_place_back(::std::string* place_back) {
  if (place_back_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete place_back_;
  }
  if (place_back) {
    set_has_place_back();
    place_back_ = place_back;
  } else {
    clear_has_place_back();
    place_back_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.TravelInfo.place_back)
}

// required string place_to = 4;
inline bool TravelInfo::has_place_to() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TravelInfo::set_has_place_to() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TravelInfo::clear_has_place_to() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TravelInfo::clear_place_to() {
  if (place_to_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_to_->clear();
  }
  clear_has_place_to();
}
inline const ::std::string& TravelInfo::place_to() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.TravelInfo.place_to)
  return *place_to_;
}
inline void TravelInfo::set_place_to(const ::std::string& value) {
  set_has_place_to();
  if (place_to_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_to_ = new ::std::string;
  }
  place_to_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.TravelInfo.place_to)
}
inline void TravelInfo::set_place_to(const char* value) {
  set_has_place_to();
  if (place_to_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_to_ = new ::std::string;
  }
  place_to_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.TravelInfo.place_to)
}
inline void TravelInfo::set_place_to(const char* value, size_t size) {
  set_has_place_to();
  if (place_to_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_to_ = new ::std::string;
  }
  place_to_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.TravelInfo.place_to)
}
inline ::std::string* TravelInfo::mutable_place_to() {
  set_has_place_to();
  if (place_to_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_to_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.TravelInfo.place_to)
  return place_to_;
}
inline ::std::string* TravelInfo::release_place_to() {
  clear_has_place_to();
  if (place_to_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = place_to_;
    place_to_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TravelInfo::set_allocated_place_to(::std::string* place_to) {
  if (place_to_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete place_to_;
  }
  if (place_to) {
    set_has_place_to();
    place_to_ = place_to;
  } else {
    clear_has_place_to();
    place_to_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.TravelInfo.place_to)
}

// required string date_from = 5;
inline bool TravelInfo::has_date_from() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TravelInfo::set_has_date_from() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TravelInfo::clear_has_date_from() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TravelInfo::clear_date_from() {
  if (date_from_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    date_from_->clear();
  }
  clear_has_date_from();
}
inline const ::std::string& TravelInfo::date_from() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.TravelInfo.date_from)
  return *date_from_;
}
inline void TravelInfo::set_date_from(const ::std::string& value) {
  set_has_date_from();
  if (date_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    date_from_ = new ::std::string;
  }
  date_from_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.TravelInfo.date_from)
}
inline void TravelInfo::set_date_from(const char* value) {
  set_has_date_from();
  if (date_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    date_from_ = new ::std::string;
  }
  date_from_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.TravelInfo.date_from)
}
inline void TravelInfo::set_date_from(const char* value, size_t size) {
  set_has_date_from();
  if (date_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    date_from_ = new ::std::string;
  }
  date_from_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.TravelInfo.date_from)
}
inline ::std::string* TravelInfo::mutable_date_from() {
  set_has_date_from();
  if (date_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    date_from_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.TravelInfo.date_from)
  return date_from_;
}
inline ::std::string* TravelInfo::release_date_from() {
  clear_has_date_from();
  if (date_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = date_from_;
    date_from_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TravelInfo::set_allocated_date_from(::std::string* date_from) {
  if (date_from_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete date_from_;
  }
  if (date_from) {
    set_has_date_from();
    date_from_ = date_from;
  } else {
    clear_has_date_from();
    date_from_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.TravelInfo.date_from)
}

// required string date_to = 6;
inline bool TravelInfo::has_date_to() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TravelInfo::set_has_date_to() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TravelInfo::clear_has_date_to() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TravelInfo::clear_date_to() {
  if (date_to_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    date_to_->clear();
  }
  clear_has_date_to();
}
inline const ::std::string& TravelInfo::date_to() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.TravelInfo.date_to)
  return *date_to_;
}
inline void TravelInfo::set_date_to(const ::std::string& value) {
  set_has_date_to();
  if (date_to_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    date_to_ = new ::std::string;
  }
  date_to_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.TravelInfo.date_to)
}
inline void TravelInfo::set_date_to(const char* value) {
  set_has_date_to();
  if (date_to_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    date_to_ = new ::std::string;
  }
  date_to_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.TravelInfo.date_to)
}
inline void TravelInfo::set_date_to(const char* value, size_t size) {
  set_has_date_to();
  if (date_to_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    date_to_ = new ::std::string;
  }
  date_to_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.TravelInfo.date_to)
}
inline ::std::string* TravelInfo::mutable_date_to() {
  set_has_date_to();
  if (date_to_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    date_to_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.TravelInfo.date_to)
  return date_to_;
}
inline ::std::string* TravelInfo::release_date_to() {
  clear_has_date_to();
  if (date_to_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = date_to_;
    date_to_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TravelInfo::set_allocated_date_to(::std::string* date_to) {
  if (date_to_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete date_to_;
  }
  if (date_to) {
    set_has_date_to();
    date_to_ = date_to;
  } else {
    clear_has_date_to();
    date_to_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.TravelInfo.date_to)
}

// -------------------------------------------------------------------

// TrafficInfo

// required string traffic_time_from = 1;
inline bool TrafficInfo::has_traffic_time_from() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrafficInfo::set_has_traffic_time_from() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrafficInfo::clear_has_traffic_time_from() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrafficInfo::clear_traffic_time_from() {
  if (traffic_time_from_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    traffic_time_from_->clear();
  }
  clear_has_traffic_time_from();
}
inline const ::std::string& TrafficInfo::traffic_time_from() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.TrafficInfo.traffic_time_from)
  return *traffic_time_from_;
}
inline void TrafficInfo::set_traffic_time_from(const ::std::string& value) {
  set_has_traffic_time_from();
  if (traffic_time_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    traffic_time_from_ = new ::std::string;
  }
  traffic_time_from_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.TrafficInfo.traffic_time_from)
}
inline void TrafficInfo::set_traffic_time_from(const char* value) {
  set_has_traffic_time_from();
  if (traffic_time_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    traffic_time_from_ = new ::std::string;
  }
  traffic_time_from_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.TrafficInfo.traffic_time_from)
}
inline void TrafficInfo::set_traffic_time_from(const char* value, size_t size) {
  set_has_traffic_time_from();
  if (traffic_time_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    traffic_time_from_ = new ::std::string;
  }
  traffic_time_from_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.TrafficInfo.traffic_time_from)
}
inline ::std::string* TrafficInfo::mutable_traffic_time_from() {
  set_has_traffic_time_from();
  if (traffic_time_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    traffic_time_from_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.TrafficInfo.traffic_time_from)
  return traffic_time_from_;
}
inline ::std::string* TrafficInfo::release_traffic_time_from() {
  clear_has_traffic_time_from();
  if (traffic_time_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = traffic_time_from_;
    traffic_time_from_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TrafficInfo::set_allocated_traffic_time_from(::std::string* traffic_time_from) {
  if (traffic_time_from_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete traffic_time_from_;
  }
  if (traffic_time_from) {
    set_has_traffic_time_from();
    traffic_time_from_ = traffic_time_from;
  } else {
    clear_has_traffic_time_from();
    traffic_time_from_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.TrafficInfo.traffic_time_from)
}

// required string traffic_time_to = 2;
inline bool TrafficInfo::has_traffic_time_to() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrafficInfo::set_has_traffic_time_to() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrafficInfo::clear_has_traffic_time_to() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrafficInfo::clear_traffic_time_to() {
  if (traffic_time_to_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    traffic_time_to_->clear();
  }
  clear_has_traffic_time_to();
}
inline const ::std::string& TrafficInfo::traffic_time_to() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.TrafficInfo.traffic_time_to)
  return *traffic_time_to_;
}
inline void TrafficInfo::set_traffic_time_to(const ::std::string& value) {
  set_has_traffic_time_to();
  if (traffic_time_to_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    traffic_time_to_ = new ::std::string;
  }
  traffic_time_to_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.TrafficInfo.traffic_time_to)
}
inline void TrafficInfo::set_traffic_time_to(const char* value) {
  set_has_traffic_time_to();
  if (traffic_time_to_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    traffic_time_to_ = new ::std::string;
  }
  traffic_time_to_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.TrafficInfo.traffic_time_to)
}
inline void TrafficInfo::set_traffic_time_to(const char* value, size_t size) {
  set_has_traffic_time_to();
  if (traffic_time_to_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    traffic_time_to_ = new ::std::string;
  }
  traffic_time_to_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.TrafficInfo.traffic_time_to)
}
inline ::std::string* TrafficInfo::mutable_traffic_time_to() {
  set_has_traffic_time_to();
  if (traffic_time_to_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    traffic_time_to_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.TrafficInfo.traffic_time_to)
  return traffic_time_to_;
}
inline ::std::string* TrafficInfo::release_traffic_time_to() {
  clear_has_traffic_time_to();
  if (traffic_time_to_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = traffic_time_to_;
    traffic_time_to_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TrafficInfo::set_allocated_traffic_time_to(::std::string* traffic_time_to) {
  if (traffic_time_to_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete traffic_time_to_;
  }
  if (traffic_time_to) {
    set_has_traffic_time_to();
    traffic_time_to_ = traffic_time_to;
  } else {
    clear_has_traffic_time_to();
    traffic_time_to_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.TrafficInfo.traffic_time_to)
}

// required uint32 travel_type = 3;
inline bool TrafficInfo::has_travel_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TrafficInfo::set_has_travel_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TrafficInfo::clear_has_travel_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TrafficInfo::clear_travel_type() {
  travel_type_ = 0u;
  clear_has_travel_type();
}
inline ::google::protobuf::uint32 TrafficInfo::travel_type() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.TrafficInfo.travel_type)
  return travel_type_;
}
inline void TrafficInfo::set_travel_type(::google::protobuf::uint32 value) {
  set_has_travel_type();
  travel_type_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.TrafficInfo.travel_type)
}

// -------------------------------------------------------------------

// PlayInfo

// required .IM.Buddy.PlayQualityType play_quality = 1;
inline bool PlayInfo::has_play_quality() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayInfo::set_has_play_quality() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayInfo::clear_has_play_quality() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayInfo::clear_play_quality() {
  play_quality_ = 1;
  clear_has_play_quality();
}
inline ::IM::Buddy::PlayQualityType PlayInfo::play_quality() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.PlayInfo.play_quality)
  return static_cast< ::IM::Buddy::PlayQualityType >(play_quality_);
}
inline void PlayInfo::set_play_quality(::IM::Buddy::PlayQualityType value) {
  assert(::IM::Buddy::PlayQualityType_IsValid(value));
  set_has_play_quality();
  play_quality_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.PlayInfo.play_quality)
}

// required string play_time_from = 2;
inline bool PlayInfo::has_play_time_from() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayInfo::set_has_play_time_from() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayInfo::clear_has_play_time_from() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayInfo::clear_play_time_from() {
  if (play_time_from_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    play_time_from_->clear();
  }
  clear_has_play_time_from();
}
inline const ::std::string& PlayInfo::play_time_from() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.PlayInfo.play_time_from)
  return *play_time_from_;
}
inline void PlayInfo::set_play_time_from(const ::std::string& value) {
  set_has_play_time_from();
  if (play_time_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    play_time_from_ = new ::std::string;
  }
  play_time_from_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.PlayInfo.play_time_from)
}
inline void PlayInfo::set_play_time_from(const char* value) {
  set_has_play_time_from();
  if (play_time_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    play_time_from_ = new ::std::string;
  }
  play_time_from_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.PlayInfo.play_time_from)
}
inline void PlayInfo::set_play_time_from(const char* value, size_t size) {
  set_has_play_time_from();
  if (play_time_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    play_time_from_ = new ::std::string;
  }
  play_time_from_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.PlayInfo.play_time_from)
}
inline ::std::string* PlayInfo::mutable_play_time_from() {
  set_has_play_time_from();
  if (play_time_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    play_time_from_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.PlayInfo.play_time_from)
  return play_time_from_;
}
inline ::std::string* PlayInfo::release_play_time_from() {
  clear_has_play_time_from();
  if (play_time_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = play_time_from_;
    play_time_from_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PlayInfo::set_allocated_play_time_from(::std::string* play_time_from) {
  if (play_time_from_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete play_time_from_;
  }
  if (play_time_from) {
    set_has_play_time_from();
    play_time_from_ = play_time_from;
  } else {
    clear_has_play_time_from();
    play_time_from_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.PlayInfo.play_time_from)
}

// required string play_time_to = 3;
inline bool PlayInfo::has_play_time_to() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayInfo::set_has_play_time_to() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayInfo::clear_has_play_time_to() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayInfo::clear_play_time_to() {
  if (play_time_to_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    play_time_to_->clear();
  }
  clear_has_play_time_to();
}
inline const ::std::string& PlayInfo::play_time_to() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.PlayInfo.play_time_to)
  return *play_time_to_;
}
inline void PlayInfo::set_play_time_to(const ::std::string& value) {
  set_has_play_time_to();
  if (play_time_to_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    play_time_to_ = new ::std::string;
  }
  play_time_to_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.PlayInfo.play_time_to)
}
inline void PlayInfo::set_play_time_to(const char* value) {
  set_has_play_time_to();
  if (play_time_to_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    play_time_to_ = new ::std::string;
  }
  play_time_to_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.PlayInfo.play_time_to)
}
inline void PlayInfo::set_play_time_to(const char* value, size_t size) {
  set_has_play_time_to();
  if (play_time_to_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    play_time_to_ = new ::std::string;
  }
  play_time_to_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.PlayInfo.play_time_to)
}
inline ::std::string* PlayInfo::mutable_play_time_to() {
  set_has_play_time_to();
  if (play_time_to_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    play_time_to_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.PlayInfo.play_time_to)
  return play_time_to_;
}
inline ::std::string* PlayInfo::release_play_time_to() {
  clear_has_play_time_to();
  if (play_time_to_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = play_time_to_;
    play_time_to_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PlayInfo::set_allocated_play_time_to(::std::string* play_time_to) {
  if (play_time_to_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete play_time_to_;
  }
  if (play_time_to) {
    set_has_play_time_to();
    play_time_to_ = play_time_to;
  } else {
    clear_has_play_time_to();
    play_time_to_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.PlayInfo.play_time_to)
}

// required uint32 city_traffic = 4;
inline bool PlayInfo::has_city_traffic() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayInfo::set_has_city_traffic() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayInfo::clear_has_city_traffic() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayInfo::clear_city_traffic() {
  city_traffic_ = 0u;
  clear_has_city_traffic();
}
inline ::google::protobuf::uint32 PlayInfo::city_traffic() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.PlayInfo.city_traffic)
  return city_traffic_;
}
inline void PlayInfo::set_city_traffic(::google::protobuf::uint32 value) {
  set_has_city_traffic();
  city_traffic_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.PlayInfo.city_traffic)
}

// required .IM.Buddy.HotelPositionType hotel_position = 5;
inline bool PlayInfo::has_hotel_position() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PlayInfo::set_has_hotel_position() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PlayInfo::clear_has_hotel_position() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PlayInfo::clear_hotel_position() {
  hotel_position_ = 1;
  clear_has_hotel_position();
}
inline ::IM::Buddy::HotelPositionType PlayInfo::hotel_position() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.PlayInfo.hotel_position)
  return static_cast< ::IM::Buddy::HotelPositionType >(hotel_position_);
}
inline void PlayInfo::set_hotel_position(::IM::Buddy::HotelPositionType value) {
  assert(::IM::Buddy::HotelPositionType_IsValid(value));
  set_has_hotel_position();
  hotel_position_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.PlayInfo.hotel_position)
}

// -------------------------------------------------------------------

// TravelDetail

// required uint32 db_idx = 1;
inline bool TravelDetail::has_db_idx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TravelDetail::set_has_db_idx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TravelDetail::clear_has_db_idx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TravelDetail::clear_db_idx() {
  db_idx_ = 0u;
  clear_has_db_idx();
}
inline ::google::protobuf::uint32 TravelDetail::db_idx() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.TravelDetail.db_idx)
  return db_idx_;
}
inline void TravelDetail::set_db_idx(::google::protobuf::uint32 value) {
  set_has_db_idx();
  db_idx_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.TravelDetail.db_idx)
}

// required .IM.Buddy.TravelInfo travel_info = 2;
inline bool TravelDetail::has_travel_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TravelDetail::set_has_travel_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TravelDetail::clear_has_travel_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TravelDetail::clear_travel_info() {
  if (travel_info_ != NULL) travel_info_->::IM::Buddy::TravelInfo::Clear();
  clear_has_travel_info();
}
inline const ::IM::Buddy::TravelInfo& TravelDetail::travel_info() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.TravelDetail.travel_info)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return travel_info_ != NULL ? *travel_info_ : *default_instance().travel_info_;
#else
  return travel_info_ != NULL ? *travel_info_ : *default_instance_->travel_info_;
#endif
}
inline ::IM::Buddy::TravelInfo* TravelDetail::mutable_travel_info() {
  set_has_travel_info();
  if (travel_info_ == NULL) travel_info_ = new ::IM::Buddy::TravelInfo;
  // @@protoc_insertion_point(field_mutable:IM.Buddy.TravelDetail.travel_info)
  return travel_info_;
}
inline ::IM::Buddy::TravelInfo* TravelDetail::release_travel_info() {
  clear_has_travel_info();
  ::IM::Buddy::TravelInfo* temp = travel_info_;
  travel_info_ = NULL;
  return temp;
}
inline void TravelDetail::set_allocated_travel_info(::IM::Buddy::TravelInfo* travel_info) {
  delete travel_info_;
  travel_info_ = travel_info;
  if (travel_info) {
    set_has_travel_info();
  } else {
    clear_has_travel_info();
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.TravelDetail.travel_info)
}

// required .IM.Buddy.TrafficInfo traffic_info = 3;
inline bool TravelDetail::has_traffic_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TravelDetail::set_has_traffic_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TravelDetail::clear_has_traffic_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TravelDetail::clear_traffic_info() {
  if (traffic_info_ != NULL) traffic_info_->::IM::Buddy::TrafficInfo::Clear();
  clear_has_traffic_info();
}
inline const ::IM::Buddy::TrafficInfo& TravelDetail::traffic_info() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.TravelDetail.traffic_info)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return traffic_info_ != NULL ? *traffic_info_ : *default_instance().traffic_info_;
#else
  return traffic_info_ != NULL ? *traffic_info_ : *default_instance_->traffic_info_;
#endif
}
inline ::IM::Buddy::TrafficInfo* TravelDetail::mutable_traffic_info() {
  set_has_traffic_info();
  if (traffic_info_ == NULL) traffic_info_ = new ::IM::Buddy::TrafficInfo;
  // @@protoc_insertion_point(field_mutable:IM.Buddy.TravelDetail.traffic_info)
  return traffic_info_;
}
inline ::IM::Buddy::TrafficInfo* TravelDetail::release_traffic_info() {
  clear_has_traffic_info();
  ::IM::Buddy::TrafficInfo* temp = traffic_info_;
  traffic_info_ = NULL;
  return temp;
}
inline void TravelDetail::set_allocated_traffic_info(::IM::Buddy::TrafficInfo* traffic_info) {
  delete traffic_info_;
  traffic_info_ = traffic_info;
  if (traffic_info) {
    set_has_traffic_info();
  } else {
    clear_has_traffic_info();
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.TravelDetail.traffic_info)
}

// required .IM.Buddy.PlayInfo play_info = 4;
inline bool TravelDetail::has_play_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TravelDetail::set_has_play_info() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TravelDetail::clear_has_play_info() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TravelDetail::clear_play_info() {
  if (play_info_ != NULL) play_info_->::IM::Buddy::PlayInfo::Clear();
  clear_has_play_info();
}
inline const ::IM::Buddy::PlayInfo& TravelDetail::play_info() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.TravelDetail.play_info)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return play_info_ != NULL ? *play_info_ : *default_instance().play_info_;
#else
  return play_info_ != NULL ? *play_info_ : *default_instance_->play_info_;
#endif
}
inline ::IM::Buddy::PlayInfo* TravelDetail::mutable_play_info() {
  set_has_play_info();
  if (play_info_ == NULL) play_info_ = new ::IM::Buddy::PlayInfo;
  // @@protoc_insertion_point(field_mutable:IM.Buddy.TravelDetail.play_info)
  return play_info_;
}
inline ::IM::Buddy::PlayInfo* TravelDetail::release_play_info() {
  clear_has_play_info();
  ::IM::Buddy::PlayInfo* temp = play_info_;
  play_info_ = NULL;
  return temp;
}
inline void TravelDetail::set_allocated_play_info(::IM::Buddy::PlayInfo* play_info) {
  delete play_info_;
  play_info_ = play_info;
  if (play_info) {
    set_has_play_info();
  } else {
    clear_has_play_info();
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.TravelDetail.play_info)
}

// required uint32 cost = 5;
inline bool TravelDetail::has_cost() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TravelDetail::set_has_cost() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TravelDetail::clear_has_cost() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TravelDetail::clear_cost() {
  cost_ = 0u;
  clear_has_cost();
}
inline ::google::protobuf::uint32 TravelDetail::cost() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.TravelDetail.cost)
  return cost_;
}
inline void TravelDetail::set_cost(::google::protobuf::uint32 value) {
  set_has_cost();
  cost_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.TravelDetail.cost)
}

// -------------------------------------------------------------------

// GetTravelListReq

// required uint32 user_id = 1;
inline bool GetTravelListReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetTravelListReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetTravelListReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetTravelListReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 GetTravelListReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.GetTravelListReq.user_id)
  return user_id_;
}
inline void GetTravelListReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.GetTravelListReq.user_id)
}

// optional bytes attach_data = 20;
inline bool GetTravelListReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetTravelListReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetTravelListReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetTravelListReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& GetTravelListReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.GetTravelListReq.attach_data)
  return *attach_data_;
}
inline void GetTravelListReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.GetTravelListReq.attach_data)
}
inline void GetTravelListReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.GetTravelListReq.attach_data)
}
inline void GetTravelListReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.GetTravelListReq.attach_data)
}
inline ::std::string* GetTravelListReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.GetTravelListReq.attach_data)
  return attach_data_;
}
inline ::std::string* GetTravelListReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetTravelListReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.GetTravelListReq.attach_data)
}

// -------------------------------------------------------------------

// GetTravelTripListRsp

// required uint32 user_id = 1;
inline bool GetTravelTripListRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetTravelTripListRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetTravelTripListRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetTravelTripListRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 GetTravelTripListRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.GetTravelTripListRsp.user_id)
  return user_id_;
}
inline void GetTravelTripListRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.GetTravelTripListRsp.user_id)
}

// required uint32 result_code = 2;
inline bool GetTravelTripListRsp::has_result_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetTravelTripListRsp::set_has_result_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetTravelTripListRsp::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetTravelTripListRsp::clear_result_code() {
  result_code_ = 0u;
  clear_has_result_code();
}
inline ::google::protobuf::uint32 GetTravelTripListRsp::result_code() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.GetTravelTripListRsp.result_code)
  return result_code_;
}
inline void GetTravelTripListRsp::set_result_code(::google::protobuf::uint32 value) {
  set_has_result_code();
  result_code_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.GetTravelTripListRsp.result_code)
}

// repeated .IM.Buddy.TravelDetail travel_detail = 3;
inline int GetTravelTripListRsp::travel_detail_size() const {
  return travel_detail_.size();
}
inline void GetTravelTripListRsp::clear_travel_detail() {
  travel_detail_.Clear();
}
inline const ::IM::Buddy::TravelDetail& GetTravelTripListRsp::travel_detail(int index) const {
  // @@protoc_insertion_point(field_get:IM.Buddy.GetTravelTripListRsp.travel_detail)
  return travel_detail_.Get(index);
}
inline ::IM::Buddy::TravelDetail* GetTravelTripListRsp::mutable_travel_detail(int index) {
  // @@protoc_insertion_point(field_mutable:IM.Buddy.GetTravelTripListRsp.travel_detail)
  return travel_detail_.Mutable(index);
}
inline ::IM::Buddy::TravelDetail* GetTravelTripListRsp::add_travel_detail() {
  // @@protoc_insertion_point(field_add:IM.Buddy.GetTravelTripListRsp.travel_detail)
  return travel_detail_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::Buddy::TravelDetail >&
GetTravelTripListRsp::travel_detail() const {
  // @@protoc_insertion_point(field_list:IM.Buddy.GetTravelTripListRsp.travel_detail)
  return travel_detail_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::Buddy::TravelDetail >*
GetTravelTripListRsp::mutable_travel_detail() {
  // @@protoc_insertion_point(field_mutable_list:IM.Buddy.GetTravelTripListRsp.travel_detail)
  return &travel_detail_;
}

// optional bytes attach_data = 20;
inline bool GetTravelTripListRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetTravelTripListRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetTravelTripListRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetTravelTripListRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& GetTravelTripListRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.GetTravelTripListRsp.attach_data)
  return *attach_data_;
}
inline void GetTravelTripListRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.GetTravelTripListRsp.attach_data)
}
inline void GetTravelTripListRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.GetTravelTripListRsp.attach_data)
}
inline void GetTravelTripListRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.GetTravelTripListRsp.attach_data)
}
inline ::std::string* GetTravelTripListRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.GetTravelTripListRsp.attach_data)
  return attach_data_;
}
inline ::std::string* GetTravelTripListRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetTravelTripListRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.GetTravelTripListRsp.attach_data)
}

// -------------------------------------------------------------------

// CreateTravelReq

// required uint32 user_id = 1;
inline bool CreateTravelReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateTravelReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateTravelReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateTravelReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 CreateTravelReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.CreateTravelReq.user_id)
  return user_id_;
}
inline void CreateTravelReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.CreateTravelReq.user_id)
}

// required .IM.Buddy.TravelDetail travel_detail = 2;
inline bool CreateTravelReq::has_travel_detail() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateTravelReq::set_has_travel_detail() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateTravelReq::clear_has_travel_detail() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateTravelReq::clear_travel_detail() {
  if (travel_detail_ != NULL) travel_detail_->::IM::Buddy::TravelDetail::Clear();
  clear_has_travel_detail();
}
inline const ::IM::Buddy::TravelDetail& CreateTravelReq::travel_detail() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.CreateTravelReq.travel_detail)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return travel_detail_ != NULL ? *travel_detail_ : *default_instance().travel_detail_;
#else
  return travel_detail_ != NULL ? *travel_detail_ : *default_instance_->travel_detail_;
#endif
}
inline ::IM::Buddy::TravelDetail* CreateTravelReq::mutable_travel_detail() {
  set_has_travel_detail();
  if (travel_detail_ == NULL) travel_detail_ = new ::IM::Buddy::TravelDetail;
  // @@protoc_insertion_point(field_mutable:IM.Buddy.CreateTravelReq.travel_detail)
  return travel_detail_;
}
inline ::IM::Buddy::TravelDetail* CreateTravelReq::release_travel_detail() {
  clear_has_travel_detail();
  ::IM::Buddy::TravelDetail* temp = travel_detail_;
  travel_detail_ = NULL;
  return temp;
}
inline void CreateTravelReq::set_allocated_travel_detail(::IM::Buddy::TravelDetail* travel_detail) {
  delete travel_detail_;
  travel_detail_ = travel_detail;
  if (travel_detail) {
    set_has_travel_detail();
  } else {
    clear_has_travel_detail();
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.CreateTravelReq.travel_detail)
}

// optional bytes attach_data = 20;
inline bool CreateTravelReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CreateTravelReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CreateTravelReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CreateTravelReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& CreateTravelReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.CreateTravelReq.attach_data)
  return *attach_data_;
}
inline void CreateTravelReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.CreateTravelReq.attach_data)
}
inline void CreateTravelReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.CreateTravelReq.attach_data)
}
inline void CreateTravelReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.CreateTravelReq.attach_data)
}
inline ::std::string* CreateTravelReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.CreateTravelReq.attach_data)
  return attach_data_;
}
inline ::std::string* CreateTravelReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CreateTravelReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.CreateTravelReq.attach_data)
}

// -------------------------------------------------------------------

// CreateTravelRsp

// required uint32 user_id = 1;
inline bool CreateTravelRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateTravelRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateTravelRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateTravelRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 CreateTravelRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.CreateTravelRsp.user_id)
  return user_id_;
}
inline void CreateTravelRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.CreateTravelRsp.user_id)
}

// required uint32 result_code = 2;
inline bool CreateTravelRsp::has_result_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateTravelRsp::set_has_result_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateTravelRsp::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateTravelRsp::clear_result_code() {
  result_code_ = 0u;
  clear_has_result_code();
}
inline ::google::protobuf::uint32 CreateTravelRsp::result_code() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.CreateTravelRsp.result_code)
  return result_code_;
}
inline void CreateTravelRsp::set_result_code(::google::protobuf::uint32 value) {
  set_has_result_code();
  result_code_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.CreateTravelRsp.result_code)
}

// required uint32 db_idx = 3;
inline bool CreateTravelRsp::has_db_idx() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CreateTravelRsp::set_has_db_idx() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CreateTravelRsp::clear_has_db_idx() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CreateTravelRsp::clear_db_idx() {
  db_idx_ = 0u;
  clear_has_db_idx();
}
inline ::google::protobuf::uint32 CreateTravelRsp::db_idx() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.CreateTravelRsp.db_idx)
  return db_idx_;
}
inline void CreateTravelRsp::set_db_idx(::google::protobuf::uint32 value) {
  set_has_db_idx();
  db_idx_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.CreateTravelRsp.db_idx)
}

// optional bytes attach_data = 20;
inline bool CreateTravelRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CreateTravelRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CreateTravelRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CreateTravelRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& CreateTravelRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.CreateTravelRsp.attach_data)
  return *attach_data_;
}
inline void CreateTravelRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.CreateTravelRsp.attach_data)
}
inline void CreateTravelRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.CreateTravelRsp.attach_data)
}
inline void CreateTravelRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.CreateTravelRsp.attach_data)
}
inline ::std::string* CreateTravelRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.CreateTravelRsp.attach_data)
  return attach_data_;
}
inline ::std::string* CreateTravelRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CreateTravelRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.CreateTravelRsp.attach_data)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Buddy
}  // namespace IM

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_IM_2eBuddy_2eproto__INCLUDED
